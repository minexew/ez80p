; Zilog eZ80 ANSI C Compiler Release 3.3
; -nomodsect -optspeed -noreduceopt -peephole -globalopt
; -localcse -const=ROM 
	FILE	"..\MAIN.C"
	.assume ADL=1
	SEGMENT BSS
_GenericPnt2:
	DS	3
_TxtPnt:
	DS	3
_GenericPnt:
	DS	3
_K_A:
	DS	1
_K_B:
	DS	1
_K_C:
	DS	1
_K_E:
	DS	1
_K_HL:
	DS	2*1
_K_DE:
	DS	2*1
_K_xHL:
	DS	3
_K_xDE:
	DS	3
	SEGMENT STRSECT
L__0:
	DB	"USE: PCXVIEW [filename]"
	DB	10,13,0
	SEGMENT DATA
_UseTxt:
	DW24	L__0
	SEGMENT STRSECT
L__1:
	DB	"File not found!"
	DB	10,13,0
	SEGMENT DATA
_FileOpenError:
	DW24	L__1
	SEGMENT STRSECT
L__2:
	DB	"Invalid PCX file!"
	DB	10,13,0
	SEGMENT DATA
_NonPcxFile:
	DW24	L__2
	SEGMENT STRSECT
L__3:
	DB	"Graphics Resolution: "
	DB	0
	SEGMENT DATA
_PcxSize:
	DW24	L__3
	SEGMENT BSS
_Header:
	DS	128
	SEGMENT DATA
_PntHeader:
	DW24	_Header
_VideoMem:
	DW24	8388608
_VideoMemTmp:
	DW24	12582912
	SEGMENT BSS
_convBuf:
	DS	4
_MinX:
	DS	2*1
_MinY:
	DS	2*1
_MaxX:
	DS	2*1
_MaxY:
	DS	2*1
_XSize:
	DS	2*1
_YSize:
	DS	2*1
_StartX:
	DS	2*1
_StartY:
	DS	2*1
_VideoX:
	DS	2*1
_VideoY:
	DS	2*1
_PosX:
	DS	2*1
_PosY:
	DS	2*1
_PcxPalette:
	DS	512
_TmpPal:
	DS	768
	SEGMENT DATA
_PntPal:
	DW24	_TmpPal
	SEGMENT BSS
_YOffset:
	DS	1440
;    1	/*
;    2		PCXVIEW: simple pcx viewer for PROSE
;    3		
;    4		coded by Calogiuri Enzo Antonio for PROSE community.	
;    5	*/
;    6	
;    7	#include <String.h>
;    8	
;    9	#include "PROSE_Header.h"
;   10	
;   11	#define RGB2WORD(r,g,b)         ((unsigned short) ((r/16<<8)+(g/16<<4)+(b/16)))
;   12	
;   13	static char *UseTxt = "USE: PCXVIEW [filename]\n\r";
;   14	static char *FileOpenError = "File not found!\n\r";
;   15	static char *NonPcxFile = "Invalid PCX file!\n\r";
;   16	static char *PcxSize = "Graphics Resolution: ";
;   17	
;   18	static char *TxtPnt;
;   19	static char Header[128];
;   20	char *PntHeader = Header;
;   21	char *VideoMem = (char *)0x0800000;
;   22	char *VideoMemTmp = (char *)0x0C00000;
;   23	char convBuf[4];
;   24	short MinX, MinY, MaxX, MaxY;
;   25	short XSize, YSize, StartX, StartY;
;   26	short VideoX, VideoY, PosX, PosY;
;   27	unsigned short PcxPalette[256];
;   28	unsigned char TmpPal[256*3];
;   29	unsigned char *PntPal = TmpPal;
;   30	unsigned int YOffset[480];
	SEGMENT CODE
;   31	
;   32	void ShowMsg(const char *Txt);
;   33	void Make_Short(unsigned char a, unsigned char b, short *Val);
;   34	void uitoa(unsigned int val, char *string);
;   35	
;   36	void BuildOffset(void);
;   37	
;   38	void LoadPcxPalette(void);
;   39	void LoadPcxFile(void);
;   40	void DecodePcxFile(void);
;   41	
;   42	void PutPcxPixel(unsigned char Px);
;   43	
;   44	void Set_320_240_Mode(void);
;   45	void Set_640_480_Mode(void);
;   46	
;   47	void main(void)
;   48	{
_main:
;   49		INIT_HARDWARE;
PB_DR		equ 09Ah
PB_DDR		equ 09Bh
PB_ALT1		equ 09Ch
PB_ALT2		equ 09Dh
PC_DR		equ 09Eh
PC_DDR		equ 09Fh
PC_ALT1		equ 0A0h
PC_ALT2		equ 0A1h
PD_DR		equ 0A2h
PD_DDR		equ 0A3h
PD_ALT1		equ 0A4h
PD_ALT2		equ 0A5h
UART0_RBR	equ 0C0h
UART0_THR	equ 0C0h
UART0_BRG_L	equ 0C0h
UART0_BRG_H	equ 0C1h
UART0_IER	equ 0C1h
UART0_FCTL	equ 0C2h
UART0_LCTL	equ 0C3h
UART0_MCTL	equ 0C4h
UART0_LSR	equ 0C5h
UART0_MSR	equ 0C6h
CS0_LBR		equ 0A8h
CS0_UBR		equ 0A9h
CS0_CTL		equ 0AAh
CS1_LBR		equ 0ABh
CS1_UBR		equ 0ACh
CS1_CTL		equ 0ADh
CS2_LBR		equ 0AEh
CS2_UBR		equ 0AFh
CS2_CTL		equ 0B0h
CS3_LBR		equ 0B1h
CS3_UBR		equ 0B2h
CS3_CTL		equ 0B3h
TMR0_CTL		equ 080h
TMR0_DR_L	equ 081h
TMR0_RR_L	equ 081h
TMR0_DR_H	equ 082h
TMR0_RR_H	equ 082h
TMR_ISS		equ 092h
RTC_CTRL		equ 0EDh
RTC_ACTRL	equ 0ECh
RTC_SEC		equ 0E0h
RTC_MIN		equ 0E1h
RTC_HRS		equ 0E2h
RTC_DOW		equ 0E3h
RTC_DOM		equ 0E4h
RTC_MON		equ 0E5h
RTC_YR		equ 0E6h
RTC_CEN		equ 0E7h
port_pic_data		equ 000h
port_pic_ctrl		equ 001h
port_hw_flags		equ 001h
port_sdc_ctrl		equ 002h
port_keyboard_data	equ 002h
port_sdc_data		equ 003h
port_memory_paging	equ 004h
port_irq_ctrl		equ 005h
port_nmi_ack			equ 006h
port_ps2_ctrl		equ 007h
port_selector		equ 008h
port_mouse_data		equ 006h
port_clear_flags		equ 009h
sdc_power			equ 0h
sdc_cs				equ 1h
sdc_speed			equ 2h
sdc_serializer_busy	equ 4h
vrt					equ 5h
sysram_addr			equ 0000000h
vram_a_addr			equ 0800000h
vram_b_addr			equ 0C00000h
hw_palette			equ 0ff0000h
hw_sprite_registers	equ 0ff0800h
hw_video_parameters	equ 0ff1000h
hw_audio_registers	equ 0ff1400h
hw_video_settings	equ 0ff1800h
tilemap_parameters	equ hw_video_parameters + 00h
bitmap_parameters	equ hw_video_parameters + 20h
video_control		equ hw_video_settings + 00h
sprite_control		equ hw_video_settings + 01h
bgnd_palette_select	equ hw_video_settings + 02h
sprite_palette_select	equ hw_video_settings + 03h
right_border_position	equ hw_video_settings + 04h
os_start			equ 0A00h
prose_return		equ os_start + 14h
prose_kernal		equ os_start + 20h
;   50		INIT_KJT;
kr_mount_volumes			equ 00h
kr_get_device_info		equ 01h
kr_check_volume_format	equ 02h
kr_change_volume			equ 03h
kr_get_volume_info		equ 04h
kr_format_device			equ 05h
kr_make_dir				equ 06h
kr_change_dir			equ 07h
kr_parent_dir			equ 08h
kr_root_dir				equ 09h
kr_delete_dir			equ 0Ah
kr_find_file				equ 0Bh
kr_set_file_pointer		equ 0Ch
kr_set_load_length		equ 0Dh
kr_read_file				equ 0Eh
kr_erase_file			equ 0Fh
kr_rename_file			equ 10h
kr_create_file			equ 11h
kr_write_file			equ 12h
kr_get_total_sectors		equ 13h
kr_dir_list_first_entry	equ 14h
kr_dir_list_get_entry	equ 15h
kr_dir_list_next_entry	equ 16h
kr_read_sector			equ 17h
kr_write_sector			equ 18h
kr_file_sector_list		equ 19h
kr_get_dir_cluster		equ 1Ah
kr_set_dir_cluster		equ 1Bh
kr_get_dir_name			equ 1Ch
kr_wait_key				equ 1Dh
kr_get_key				equ 1Eh
kr_get_key_mod_flags		equ 1Fh
kr_serial_receive_header	equ 20h
kr_serial_receive_file	equ 21h
kr_serial_send_file		equ 22h
kr_serial_tx_byte		equ 23h
kr_serial_rx_byte		equ 24h
kr_print_string			equ 25h
kr_clear_screen			equ 26h
kr_wait_vrt				equ 27h
kr_set_cursor_position	equ 28h
kr_plot_char				equ 29h
kr_set_pen				equ 2Ah
kr_background_colours	equ 2Bh
kr_draw_cursor			equ 2Ch
kr_get_pen				equ 2Dh
kr_scroll_up				equ 2Eh
kr_os_display			equ 2Fh
kr_get_display_size		equ 30h
kr_get_charmap_addr_xy	equ 31h
kr_get_cursor_position	equ 32h
kr_set_envar				equ 33h
kr_get_envar				equ 34h
kr_delete_envar			equ 35h
kr_set_mouse_window		equ 36h
kr_get_mouse_position	equ 37h
kr_get_mouse_motion		equ 38h
kr_time_delay			equ 39h
kr_compare_strings		equ 3Ah
kr_hex_byte_to_ascii		equ 3Bh
kr_ascii_to_hex_word		equ 3Ch
kr_get_string			equ 3Dh
kr_get_version			equ 3Eh
kr_dont_store_registers	equ 3Fh
kr_get_font_info			equ 40h
kr_read_rtc				equ 41h
kr_write_rtc				equ 42h
kr_get_keymap_location	equ 43h
;   51		
;   52		CREATE_HEADER;
jr skip_header
db 'PRO'
mb_loc dw24 10000h
dw24 0
dw 0
dw 0
db 1
skip_header
;   53		
;   54		asm ("ld a, (hl)");				//Test command line
ld a, (hl)
;   55		asm ("or a");
or a
;   56		asm ("jr z, no_param");
jr z, no_param
;   57		
;   58		asm ("ld (_K_xHL), hl");		//Save pointer to commandline in global pseudoregister
ld (_K_xHL), hl
;   59		asm ("ld a, kr_find_file");
ld a, kr_find_file
;   60		asm ("call.lil prose_kernal");
call.lil prose_kernal
;   61		asm ("jr nz, FileError");
jr nz, FileError
;   62		
;   63		asm ("ld de, 128");				//If kr_find_file = OK then load a pcx header (128 bytes length)
ld de, 128
;   64		asm ("ld a, kr_set_load_length");
ld a, kr_set_load_length
;   65		asm ("call.lil prose_kernal");
call.lil prose_kernal
;   66		
;   67		asm ("ld hl, (_PntHeader)");
ld hl, (_PntHeader)
;   68		asm ("ld a, kr_read_file");
ld a, kr_read_file
;   69		asm ("call.lil prose_kernal");
call.lil prose_kernal
;   70		
;   71		if (Header[0] != 10)		//If the first byte of header is not 10 then error
	LD	A,(_Header)
	LD	B,A
	SEXT	HL
	LD	L,B
	OR	A,A
	LD	BC,10
	SBC	HL,BC
	JR	Z,L_1
;   72		{
;   73			ShowMsg(NonPcxFile);
	LD	BC,(_NonPcxFile)
	PUSH	BC
	CALL	_ShowMsg
	POP	BC
;   74			
;   75			asm ("xor a");
xor a
;   76			asm ("jp quitnow");
jp quitnow
;   77		}
L_1:
;   78		
;   79		Make_Short(Header[4], Header[5], &MinX);	//Build the limits of image
	LD	IY,_Header
	LEA	HL,IY+5
	LD	C,(HL)
	LD	DE,_MinX
	PUSH	DE
	LD	B,0
	PUSH	BC
	LD	C,(IY+4)
	PUSH	BC
	CALL	_Make_Short
	POP	BC
	POP	BC
	POP	BC
;   80		Make_Short(Header[6], Header[7], &MinY);
	LD	IY,_Header
	LEA	HL,IY+7
	LD	C,(HL)
	LD	DE,_MinY
	PUSH	DE
	LD	B,0
	PUSH	BC
	LD	C,(IY+6)
	PUSH	BC
	CALL	_Make_Short
	POP	BC
	POP	BC
	POP	BC
;   81		Make_Short(Header[8], Header[9], &MaxX);
	LD	IY,_Header
	LEA	HL,IY+9
	LD	C,(HL)
	LD	DE,_MaxX
	PUSH	DE
	LD	B,0
	PUSH	BC
	LD	C,(IY+8)
	PUSH	BC
	CALL	_Make_Short
	POP	BC
	POP	BC
	POP	BC
;   82		Make_Short(Header[10], Header[11], &MaxY);
	LD	IY,_Header
	LEA	HL,IY+11
	LD	C,(HL)
	LD	DE,_MaxY
	PUSH	DE
	LD	B,0
	PUSH	BC
	LD	C,(IY+10)
	PUSH	BC
	CALL	_Make_Short
	POP	BC
	POP	BC
	POP	BC
;   83		
;   84		XSize = MaxX - MinX + 1;					//Dimensions of image
	LD	BC,(_MinX)
	LD	HL,(_MaxX)
	OR	A,A
	SBC.SIS	HL,BC
	INC	HL
	LD	BC,HL
	LD	HL,_XSize
	LD	(HL),C
	INC	HL
	LD	(HL),B
;   85		YSize = MaxY - MinY + 1;
	LD	BC,(_MinY)
	LD	HL,(_MaxY)
	OR	A,A
	SBC.SIS	HL,BC
	INC	HL
	LD	BC,HL
	LD	HL,_YSize
	LD	(HL),C
	INC	HL
	LD	(HL),B
;   86		
;   87		if (XSize > 1)								//If image is valid
	LD	BC,(_XSize)
	LD.LIS	HL,1
	OR	A,A
	SBC.SIS	HL,BC
	JP	P,L__22
	JP	PE,L_21
	JR	L__23
L__22:
	JP	PO,L_21
L__23:
;   88		{
;   89			uitoa(XSize, convBuf);
	LD	BC,_convBuf
	PUSH	BC
	LD	BC,(_XSize)
	CALL	__stoi
	PUSH	HL
	CALL	_uitoa
	POP	BC
	POP	BC
;   90			
;   91			ShowMsg(PcxSize);
	LD	BC,(_PcxSize)
	PUSH	BC
	CALL	_ShowMsg
	POP	BC
;   92			ShowMsg(convBuf);
	LD	BC,_convBuf
	PUSH	BC
	CALL	_ShowMsg
	POP	BC
;   93			ShowMsg("x");
	LD	BC,L__6
	PUSH	BC
	CALL	_ShowMsg
	POP	BC
;   94			
;   95			uitoa(YSize, convBuf);
	LD	BC,_convBuf
	PUSH	BC
	LD	BC,(_YSize)
	CALL	__stoi
	PUSH	HL
	CALL	_uitoa
	POP	BC
	POP	BC
;   96			ShowMsg(convBuf);
	LD	BC,_convBuf
	PUSH	BC
	CALL	_ShowMsg
	POP	BC
;   97			ShowMsg("\n\r");						//Show on screen image dimensions
	LD	BC,L__7
	PUSH	BC
	CALL	_ShowMsg
	POP	BC
;   98			
;   99			if (XSize > 640)
	LD	BC,(_XSize)
	LD.LIS	HL,640
	OR	A,A
	SBC.SIS	HL,BC
	JP	P,L__24
	JP	PE,L_4
	JR	L__25
L__24:
	JP	PO,L_4
L__25:
;  100			{
;  101				ShowMsg("Image too big!\n\r");
	LD	BC,L__9
	PUSH	BC
	CALL	_ShowMsg
	POP	BC
;  102				asm ("xor a");
xor a
;  103				asm ("jp quitnow");
jp quitnow
;  104			}
L_4:
;  105			
;  106			if (YSize > 480)
	LD	BC,(_YSize)
	LD.LIS	HL,480
	OR	A,A
	SBC.SIS	HL,BC
	JP	P,L__26
	JP	PE,L_8
	JR	L__27
L__26:
	JP	PO,L_8
L__27:
;  107			{
;  108				ShowMsg("Image too big!\n\r");
	LD	BC,L__11
	PUSH	BC
	CALL	_ShowMsg
	POP	BC
;  109				asm ("xor a");
xor a
;  110				asm ("jp quitnow");
jp quitnow
;  111			}		
L_8:
;  112				
;  113			if ((XSize <= 320) && (YSize <= 240))
	LD	BC,(_XSize)
	LD.LIS	HL,320
	OR	A,A
	SBC.SIS	HL,BC
	JP	M,L__28
	JP	PE,L_7
	JR	L__29
L__28:
	JP	PO,L_7
L__29:
	LD	BC,(_YSize)
	LD.LIS	HL,240
	OR	A,A
	SBC.SIS	HL,BC
	JP	M,L__30
	JP	PE,L_7
	JR	L__31
L__30:
	JP	PO,L_7
L__31:
;  114			{
;  115				VideoX = 320;
	LD	HL,_VideoX
	LD	(HL),64
	INC	HL
	LD	(HL),1
;  116				VideoY = 240;
	LD	HL,_VideoY
	LD	(HL),240
	INC	HL
	LD	(HL),0
;  117			}
;  118			else
	JR	L_9
L_7:
;  119			{
;  120				VideoX = 640;
	LD	HL,_VideoX
	LD	(HL),128
	INC	HL
	LD	(HL),2
;  121				VideoY = 480;
	LD	HL,_VideoY
	LD	(HL),224
	INC	HL
	LD	(HL),1
;  122			}
L_9:
;  123			
;  124			BuildOffset();						//Precalculation Y Offset table
	CALL	_BuildOffset
;  125			
;  126			if (XSize < VideoX)					//Center the image?
	LD	BC,(_VideoX)
	LD	HL,(_XSize)
	OR	A,A
	SBC.SIS	HL,BC
	JP	P,L__32
	JP	PE,L_11
	JR	L__33
L__32:
	JP	PO,L_11
L__33:
;  127				StartX = (VideoX - XSize) / 2;
	LD	BC,(_VideoX)
	CALL	__stoi
	LD	DE,HL
	LD	BC,(_XSize)
	CALL	__stoi
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	LD	BC,2
	CALL	__idivs
	LD	BC,HL
	LD	HL,_StartX
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  128			else
	JR	L_14
L_11:
;  129				StartX = 0;
	LD	HL,_StartX
	LD	(HL),0
	INC	HL
	LD	(HL),0
L_14:
;  130			
;  131			if (YSize < VideoY)
	LD	BC,(_VideoY)
	LD	HL,(_YSize)
	OR	A,A
	SBC.SIS	HL,BC
	JP	P,L__34
	JP	PE,L_13
	JR	L__35
L__34:
	JP	PO,L_13
L__35:
;  132				StartY = (VideoY - YSize) / 2;
	LD	BC,(_VideoY)
	CALL	__stoi
	LD	DE,HL
	LD	BC,(_YSize)
	CALL	__stoi
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	LD	BC,2
	CALL	__idivs
	LD	BC,HL
	LD	HL,_StartY
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  133			else
	JR	L_15
L_13:
;  134				StartY = 0;		
	LD	HL,_StartY
	LD	(HL),0
	INC	HL
	LD	(HL),0
L_15:
;  135			
;  136			PosX = 0;
	LD	HL,_PosX
	LD	(HL),0
	INC	HL
	LD	(HL),0
;  137			PosY = 0;
	LD	HL,_PosY
;  138			
;  139			ShowMsg("Press a key...\n\r");
	LD	BC,L__16
	PUSH	BC
	LD	(HL),0
	INC	HL
	LD	(HL),0
	CALL	_ShowMsg
	POP	BC
;  140			asm ("ld a, kr_wait_key");
ld a, kr_wait_key
;  141			asm ("call.lil prose_kernal");
call.lil prose_kernal
;  142			
;  143			LoadPcxPalette();
	CALL	_LoadPcxPalette
;  144			LoadPcxFile();
	CALL	_LoadPcxFile
;  145			
;  146			if ((VideoX == 320) && (VideoY == 240))		//Choose right video mode
	LD.LIS	BC,320
	LD	HL,(_VideoX)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_18
	LD.LIS	BC,240
	LD	HL,(_VideoY)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_18
;  147				Set_320_240_Mode();
	CALL	_Set_320_240_Mode
;  148			else
	JR	L_19
L_18:
;  149				Set_640_480_Mode();		
	CALL	_Set_640_480_Mode
L_19:
;  150			
;  151			memcpy((void *)0x0ff0000, PcxPalette, sizeof(PcxPalette));	//Copy local palette to sistem's palette
	LD	BC,512
	PUSH	BC
	LD	BC,_PcxPalette
	PUSH	BC
	LD	BC,16711680
	PUSH	BC
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
;  152			
;  153			DecodePcxFile();
	CALL	_DecodePcxFile
;  154			
;  155			asm ("ld a, kr_wait_key");
ld a, kr_wait_key
;  156			asm ("call.lil prose_kernal");
call.lil prose_kernal
;  157		}
;  158		else
	JR	L_22
L_21:
;  159		{
;  160			ShowMsg("Invalid image dimensions!\n\r");
	LD	BC,L__19
	PUSH	BC
	CALL	_ShowMsg
	POP	BC
;  161			
;  162			asm ("xor a");
xor a
;  163			asm ("jp quitnow");
jp quitnow
;  164		}
L_22:
;  165		
;  166		asm ("jp endprogram");
jp endprogram
;  167		
;  168		asm ("no_param:");
no_param:
;  169		ShowMsg(UseTxt);
	LD	BC,(_UseTxt)
	PUSH	BC
	CALL	_ShowMsg
	POP	BC
;  170		asm ("xor a");
xor a
;  171		asm ("jp quitnow");
jp quitnow
;  172		
;  173		asm ("FileError:");
FileError:
;  174		ShowMsg(FileOpenError);
	LD	BC,(_FileOpenError)
	PUSH	BC
	CALL	_ShowMsg
	POP	BC
;  175		asm ("xor a");
xor a
;  176		asm ("jp quitnow");
jp quitnow
;  177		
;  178		asm ("endprogram:");	
endprogram:
;  179		asm ("ld a, kr_os_display");
ld a, kr_os_display
;  180		asm ("call.lil prose_kernal");
call.lil prose_kernal
;  181		asm ("ld a, kr_clear_screen");
ld a, kr_clear_screen
;  182		asm ("call.lil prose_kernal");	
call.lil prose_kernal
;  183		
;  184		if ((VideoX == 320) && (VideoY == 240))		
	LD.LIS	BC,320
	LD	HL,(_VideoX)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_25
	LD.LIS	BC,240
	LD	HL,(_VideoY)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_25
;  185			asm ("xor a");
xor a
;  186		else
	JR	L_26
L_25:
;  187			asm ("ld a, 0ffh");
ld a, 0ffh
L_26:
;  188		
;  189		asm ("quitnow:");	
quitnow:
;  190		asm ("jp.lil prose_return");
jp.lil prose_return
;  191	}
	RET	


;**************************** _main ***************************
;Name                         Addr/Register   Size   Type
;_FileOpenError                      STATIC      3   variable
;_UseTxt                             STATIC      3   variable
;_DecodePcxFile                      IMPORT  -----   function
;_PcxPalette                         STATIC    512   variable
;_memcpy                             IMPORT  -----   function
;_Set_640_480_Mode                   IMPORT  -----   function
;_Set_320_240_Mode                   IMPORT  -----   function
;_LoadPcxFile                        IMPORT  -----   function
;_LoadPcxPalette                     IMPORT  -----   function
;_PosY                               STATIC      2   variable
;_PosX                               STATIC      2   variable
;_StartY                             STATIC      2   variable
;_StartX                             STATIC      2   variable
;_BuildOffset                        IMPORT  -----   function
;_VideoY                             STATIC      2   variable
;_VideoX                             STATIC      2   variable
;_PcxSize                            STATIC      3   variable
;_convBuf                            STATIC      4   variable
;_uitoa                              IMPORT  -----   function
;_YSize                              STATIC      2   variable
;_XSize                              STATIC      2   variable
;_MaxY                               STATIC      2   variable
;_MaxX                               STATIC      2   variable
;_MinY                               STATIC      2   variable
;_MinX                               STATIC      2   variable
;_Make_Short                         IMPORT  -----   function
;_NonPcxFile                         STATIC      3   variable
;_ShowMsg                            IMPORT  -----   function
;_Header                             STATIC    128   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__6:
	DB	"x"
	DB	0
L__7:
	DB	10,13,0
L__9:
	DB	"Image too big!"
	DB	10,13,0
L__11:
	DB	"Image too big!"
	DB	10,13,0
L__16:
	DB	"Press a key..."
	DB	10,13,0
L__19:
	DB	"Invalid image dimensions!"
	DB	10,13,0
	SEGMENT CODE
;  192	
;  193	//Join to bytes and make a 16 bit value
;  194	void Make_Short(unsigned char a, unsigned char b, short *Val)
;  195	{
_Make_Short:
	CALL	__frameset0
;  196		*Val = (a + (b << 8));
	LD	C,(IX+9)
	LD	B,0
	LD	HL,BC
	LD	H,L
	LD	C,(IX+6)
	LD	L,0
	ADD.SIS	HL,BC
	LD	BC,HL
	LD	HL,(IX+12)
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  197	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _Make_Short ***************************
;Name                         Addr/Register   Size   Type
;Val                                  IX+12      3   parameter
;b                                     IX+9      1   parameter
;a                                     IX+6      1   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: 0 (instruction)


;  198	
;  199	//convert an integer in ascii string
;  200	void uitoa(unsigned int val, char *string)
;  201	{
_uitoa:
	LD	HL,-6
	CALL	__frameset
;  202		char index = 0, i = 0;
	LD	(IX+-1),0
	LD	(IX+-2),0
;  203		
;  204		do {
L_31:
;  205			string[index] = '0' + (val % 10);
	LD	A,(IX+-1)
	SEXT	HL
	LD	L,(IX+-1)
	LD	BC,(IX+9)
	ADD	HL,BC
	LD	(IX+-5),HL
	LD	HL,(IX+6)
	LD	BC,10
	CALL	__iremu
	LD	A,L
	ADD	A,48
	LD	HL,(IX+-5)
	LD	(HL),A
;  206			
;  207			if (string[index] > '9')
	LD	HL,(IX+-5)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,HL
	LD	HL,57
	OR	A,A
	SBC	HL,BC
	JP	P,L__41
	JP	PE,L_30
	JR	L__42
L__41:
	JP	PO,L_30
L__42:
;  208				string[index] += 'A' - '9' - 1;
	LD	HL,(IX+-5)
	LD	A,(HL)
	ADD	A,7
	LD	HL,(IX+-5)
	LD	(HL),A
L_30:
;  209			
;  210			val /= 10;
	LD	BC,10
	LD	HL,(IX+6)
	CALL	__idivu
	LD	(IX+6),HL
;  211			++index;
	INC	(IX+-1)
;  212	  } while (val != 0);
	LD	HL,(IX+6)
	OR	A,A
	LD	BC,0
	SBC	HL,BC
	JR	NZ,L_31
;  213	  
;  214	  string[index--] = '\0'; 
	LD	A,(IX+-1)
	SEXT	HL
	LD	L,(IX+-1)
	LD	BC,(IX+9)
	ADD	HL,BC
	LD	(HL),0
	DEC	(IX+-1)
;  215	  
;  216	  while (index > i)
	JR	L_35
L_36:
;  217	  {
;  218	    char tmp = string[i];
	LD	A,(IX+-2)
	SEXT	HL
	LD	L,(IX+-2)
	LD	BC,(IX+9)
	ADD	HL,BC
	LD	A,(HL)
	LD	(IX+-6),A
;  219		  
;  220	    string[i] = string[index];
	LD	A,(IX+-1)
	SEXT	HL
	LD	L,(IX+-1)
	LD	A,(IX+-2)
	LD	BC,(IX+9)
	ADD	HL,BC
	LD	IY,HL
	SEXT	HL
	LD	L,(IX+-2)
	LD	A,(IY)
	LD	BC,(IX+9)
	ADD	HL,BC
	LD	(HL),A
;  221	    string[index] = tmp;
	LD	A,(IX+-1)
	SEXT	HL
	LD	L,(IX+-1)
	LD	A,(IX+-6)
	LD	BC,(IX+9)
	ADD	HL,BC
	LD	(HL),A
;  222	    ++i;
	INC	(IX+-2)
;  223	    --index;
	DEC	(IX+-1)
;  224	  }
L_35:
	LD	A,(IX+-2)
	CP	A,(IX+-1)
	JP	M,L__43
	JP	PE,L_36
	JR	L__44
L__43:
	JP	PO,L_36
L__44:
;  225	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _uitoa ***************************
;Name                         Addr/Register   Size   Type
;tmp                                   IX-6      1   variable
;G_0                                   IX-5      3   variable
;i                                     IX-2      1   variable
;index                                 IX-1      1   variable
;string                                IX+9      3   parameter
;val                                   IX+6      3   parameter


; Stack Frame Size: 18 (bytes)
;       Spill Code: 0 (instruction)


;  226	
;  227	//Show a text :-)
;  228	void ShowMsg(const char *Txt)
;  229	{
_ShowMsg:
	CALL	__frameset0
;  230		TxtPnt = Txt;
	LD	BC,(IX+6)
	LD	(_TxtPnt),BC
;  231		
;  232		asm ("push ix");
push ix
;  233		asm ("ld hl, (_TxtPnt)");
ld hl, (_TxtPnt)
;  234		asm ("ld a, kr_print_string");
ld a, kr_print_string
;  235		asm ("call.lil prose_kernal");
call.lil prose_kernal
;  236		asm ("pop ix");	
pop ix
;  237	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _ShowMsg ***************************
;Name                         Addr/Register   Size   Type
;_TxtPnt                             STATIC      3   variable
;Txt                                   IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  238	
;  239	//Load a 768 bytes palette, then convert it in a palette useful for eZ80P
;  240	void LoadPcxPalette(void)
;  241	{
_LoadPcxPalette:
	LD	HL,-4
	CALL	__frameset
;  242		short i, a;
;  243		
;  244		ShowMsg("Loading Palette...\n\r");
	LD	BC,L__47
	PUSH	BC
	CALL	_ShowMsg
	POP	BC
;  245		
;  246		asm ("push ix");
push ix
;  247		asm ("ld hl, (_K_xHL)");
ld hl, (_K_xHL)
;  248		asm ("ld a, kr_find_file");
ld a, kr_find_file
;  249		asm ("call.lil prose_kernal");
call.lil prose_kernal
;  250		asm ("pop ix");	
pop ix
;  251		asm ("jr nz, PaletteError");
jr nz, PaletteError
;  252		asm ("ld (_K_xDE), de");
ld (_K_xDE), de
;  253		
;  254		K_xDE -= 768;
	LD	HL,(_K_xDE)
	LD	BC,-768
	ADD	HL,BC
	LD	(_K_xDE),HL
;  255		
;  256		asm ("push ix");
push ix
;  257		asm ("ld de, (_K_xDE)");	
ld de, (_K_xDE)
;  258		asm ("ld a, kr_set_file_pointer");
ld a, kr_set_file_pointer
;  259		asm ("call.lil prose_kernal");
call.lil prose_kernal
;  260		asm ("pop ix");
pop ix
;  261		
;  262		asm ("push ix");
push ix
;  263		asm ("ld de, 768");
ld de, 768
;  264		asm ("ld a, kr_set_load_length");
ld a, kr_set_load_length
;  265		asm ("call.lil prose_kernal");
call.lil prose_kernal
;  266		asm ("pop ix");
pop ix
;  267		
;  268		asm ("push ix");
push ix
;  269		asm ("ld hl, (_PntPal)");
ld hl, (_PntPal)
;  270		asm ("ld a, kr_read_file");
ld a, kr_read_file
;  271		asm ("call.lil prose_kernal");
call.lil prose_kernal
;  272		asm ("jr nz, PaletteError");
jr nz, PaletteError
;  273		asm ("pop ix");
pop ix
;  274		
;  275		a = 0;
	LD	(IX+-4),0
	LD	(IX+-3),0
	LD	(IX+-2),0
	LD	(IX+-1),0
;  276		for (i = 0; i < 256; i++)
	JR	L_42
L_40:
;  277		{
;  278			PcxPalette[i] = RGB2WORD(TmpPal[a], TmpPal[a + 1], TmpPal[a + 2]);
	LD	BC,(IX+-4)
	CALL	__stoi
	LD	BC,_TmpPal
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,16
	CALL	__idivs
	LD	A,8
	CALL	__ishl_b
	LD	DE,HL
	LD	BC,(IX+-4)
	CALL	__stoi
	INC	HL
	LD	BC,_TmpPal
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,16
	CALL	__idivs
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,DE
	LD	DE,HL
	LD	BC,(IX+-4)
	CALL	__stoi
	INC	HL
	INC	HL
	LD	BC,_TmpPal
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,16
	CALL	__idivs
	ADD	HL,DE
	LD	DE,HL
	LD	BC,(IX+-2)
	CALL	__stoi
	ADD	HL,HL
	LD	BC,_PcxPalette
	ADD	HL,BC
	LD	BC,DE
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  279			
;  280			a+=3;
	LD	IY,(IX+-4)
	LEA	HL,IY+3
	LD	(IX+-4),L
	LD	(IX+-3),H
	LD	HL,(IX+-2)
	INC	HL
	LD	(IX+-2),L
	LD	(IX+-1),H
;  281		}
L_42:
	LD.LIS	BC,256
	LD	HL,(IX+-2)
	OR	A,A
	SBC.SIS	HL,BC
	JP	M,L__50
	JP	PE,L_40
	JR	L__51
L__50:
	JP	PO,L_40
L__51:
;  282		
;  283		asm ("jp EndPalette");
jp EndPalette
;  284		
;  285		asm("PaletteError:");
PaletteError:
;  286		ShowMsg("Palette Reading error\n\r");
	LD	BC,L__49
	PUSH	BC
	CALL	_ShowMsg
	POP	BC
;  287		
;  288		asm ("EndPalette:");
EndPalette:
;  289	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _LoadPcxPalette ***************************
;Name                         Addr/Register   Size   Type
;_PcxPalette                         STATIC    512   variable
;_TmpPal                             STATIC    768   variable
;_K_xDE                              STATIC      3   variable
;_ShowMsg                            IMPORT  -----   function
;a                                     IX-4      2   variable
;i                                     IX-2      2   variable


; Stack Frame Size: 10 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__47:
	DB	"Loading Palette..."
	DB	10,13,0
L__49:
	DB	"Palette Reading error"
	DB	10,13,0
	SEGMENT CODE
;  290	
;  291	//Load the Pcx compress data in second video page mem
;  292	void LoadPcxFile(void)
;  293	{
_LoadPcxFile:
;  294		ShowMsg("Loading Pcx Data...\n\r");
	LD	BC,L__53
	PUSH	BC
	CALL	_ShowMsg
	POP	BC
;  295		
;  296		asm ("push ix");
push ix
;  297		asm ("ld hl, (_K_xHL)");
ld hl, (_K_xHL)
;  298		asm ("ld a, kr_find_file");
ld a, kr_find_file
;  299		asm ("call.lil prose_kernal");
call.lil prose_kernal
;  300		asm ("pop ix");	
pop ix
;  301		asm ("jr nz, LoadPcxError");
jr nz, LoadPcxError
;  302		asm ("ld (_K_xDE), de");
ld (_K_xDE), de
;  303		
;  304		asm ("push ix");
push ix
;  305		asm ("ld de, 128");
ld de, 128
;  306		asm ("ld a, kr_set_file_pointer");
ld a, kr_set_file_pointer
;  307		asm ("call.lil prose_kernal");
call.lil prose_kernal
;  308		asm ("pop ix");
pop ix
;  309		
;  310		K_xDE = K_xDE - (128 + 768);
	LD	HL,(_K_xDE)
	LD	BC,-896
	ADD	HL,BC
	LD	(_K_xDE),HL
;  311		
;  312		asm ("push ix");
push ix
;  313		asm ("ld de, (_K_xDE)");
ld de, (_K_xDE)
;  314		asm ("ld a, kr_set_load_length");
ld a, kr_set_load_length
;  315		asm ("call.lil prose_kernal");
call.lil prose_kernal
;  316		asm ("pop ix");
pop ix
;  317		
;  318		asm ("push ix");
push ix
;  319		asm ("ld hl, (_VideoMemTmp)");
ld hl, (_VideoMemTmp)
;  320		asm ("ld a, kr_read_file");
ld a, kr_read_file
;  321		asm ("call.lil prose_kernal");
call.lil prose_kernal
;  322		asm ("jr nz, LoadPcxError");
jr nz, LoadPcxError
;  323		asm ("pop ix");
pop ix
;  324		
;  325		asm ("jp EndLoadPcx");
jp EndLoadPcx
;  326		
;  327		asm("LoadPcxError:");
LoadPcxError:
;  328		ShowMsg("PCX Reading error\n\r");
	LD	BC,L__54
	PUSH	BC
	CALL	_ShowMsg
	POP	BC
;  329		
;  330		asm ("EndLoadPcx:");
EndLoadPcx:
;  331	}
	RET	


;**************************** _LoadPcxFile ***************************
;Name                         Addr/Register   Size   Type
;_K_xDE                              STATIC      3   variable
;_ShowMsg                            IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__53:
	DB	"Loading Pcx Data..."
	DB	10,13,0
L__54:
	DB	"PCX Reading error"
	DB	10,13,0
	SEGMENT CODE
;  332	
;  333	//Enable 320x240x256 colors
;  334	void Set_320_240_Mode(void)
;  335	{
_Set_320_240_Mode:
;  336		asm ("push ix");
push ix
;  337		
;  338		asm ("ld a, 0110b");
ld a, 0110b
;  339		asm ("ld (video_control), a");
ld (video_control), a
;  340		asm ("ld a, 0");
ld a, 0
;  341		asm ("ld (bgnd_palette_select), a");
ld (bgnd_palette_select), a
;  342		asm ("ld a, 99");
ld a, 99
;  343		asm ("ld (right_border_position), a");
ld (right_border_position), a
;  344		asm ("ld ix, bitmap_parameters");
ld ix, bitmap_parameters
;  345		asm ("ld (ix), 0");
ld (ix), 0
;  346		asm ("ld (ix+04h), 1");
ld (ix+04h), 1
;  347		asm ("ld (ix+08h), 0");
ld (ix+08h), 0
;  348		asm ("ld (ix+0ch), 0");
ld (ix+0ch), 0
;  349		asm ("ld (ix+10h), 0 + (320 / 8) - 1");
ld (ix+10h), 0 + (320 / 8) - 1
;  350		
;  351		asm ("ld hl, vram_a_addr");
ld hl, vram_a_addr
;  352		asm ("ld (hl), 0");
ld (hl), 0
;  353		asm ("push hl");
push hl
;  354		asm ("pop de");
pop de
;  355		asm ("inc de");
inc de
;  356		asm ("ld bc, 320*240");
ld bc, 320*240
;  357		asm ("dec bc");
dec bc
;  358		asm ("ldir");
ldir
;  359		
;  360		asm ("pop ix");
pop ix
;  361	}
	RET	


;**************************** _Set_320_240_Mode ***************************
;Name                         Addr/Register   Size   Type


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


;  362	
;  363	//Enable 640x480x256 colors
;  364	void Set_640_480_Mode(void)
;  365	{
_Set_640_480_Mode:
;  366		asm ("push ix");
push ix
;  367		
;  368		asm ("ld a, 0000b");
ld a, 0000b
;  369		asm ("ld (video_control), a");
ld (video_control), a
;  370		asm ("ld a, 0");
ld a, 0
;  371		asm ("ld (bgnd_palette_select), a");
ld (bgnd_palette_select), a
;  372		asm ("ld a, 99");
ld a, 99
;  373		asm ("ld (right_border_position), a");
ld (right_border_position), a
;  374		asm ("ld ix, bitmap_parameters");	
ld ix, bitmap_parameters
;  375		asm ("ld (ix), 0");
ld (ix), 0
;  376		asm ("ld (ix+04h), 1");
ld (ix+04h), 1
;  377		asm ("ld (ix+08h), 0");
ld (ix+08h), 0
;  378		asm ("ld (ix+0ch), 0");
ld (ix+0ch), 0
;  379		asm ("ld (ix+10h), 0 + (640 / 8) - 1");
ld (ix+10h), 0 + (640 / 8) - 1
;  380		
;  381		asm ("ld hl, vram_a_addr");
ld hl, vram_a_addr
;  382		asm ("ld (hl), 0");
ld (hl), 0
;  383		asm ("push hl");
push hl
;  384		asm ("pop de");
pop de
;  385		asm ("inc de");
inc de
;  386		asm ("ld bc, 640*480");
ld bc, 640*480
;  387		asm ("dec bc");
dec bc
;  388		asm ("ldir");
ldir
;  389		
;  390		asm ("pop ix");
pop ix
;  391	}
	RET	


;**************************** _Set_640_480_Mode ***************************
;Name                         Addr/Register   Size   Type


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


;  392	
;  393	//Expand compress Pcx data into raw image
;  394	void DecodePcxFile(void)
;  395	{
_DecodePcxFile:
	LD	HL,-13
	CALL	__frameset
;  396		unsigned int NumData, fsize, tmp;
;  397		register unsigned char Data;
;  398		
;  399		fsize = 0;
	LD	BC,0
	LD	(IX+-4),BC
;  400		tmp = (unsigned int)XSize * (unsigned int)YSize;
	LD	BC,(_XSize)
	CALL	__stoi
	LD	DE,HL
	LD	BC,(_YSize)
	CALL	__stoi
	LD	BC,HL
	LD	HL,DE
	CALL	__imulu
	LD	(IX+-10),HL
;  401		
;  402		while (fsize <= tmp)
	JR	L_56
L_57:
;  403		{
;  404			Data = *VideoMemTmp++;
	LD	BC,(_VideoMemTmp)
	LD	(IX+-13),BC
	LD	HL,BC
	LD	A,(HL)
	LD	(IX+-1),A
	LD	BC,(_VideoMemTmp)
	INC	BC
	LD	(_VideoMemTmp),BC
;  405			
;  406			if (Data < 192)
	LD	A,(IX+-1)
	CP	A,192
	JR	NC,L_51
;  407			{
;  408				PutPcxPixel(Data);
	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	CALL	_PutPcxPixel
	POP	BC
;  409				
;  410				fsize++;
	LD	BC,(IX+-4)
	INC	BC
	LD	(IX+-4),BC
;  411				
;  412				continue;
	JR	L_56
;  413			}
L_51:
;  414			
;  415			NumData = Data & 0x3F;
	LD	A,(IX+-1)
	AND	A,63
	UEXT	HL
	LD	L,A
	LD	(IX+-7),HL
;  416			fsize += NumData;
	LD	BC,(IX+-4)
	ADD	HL,BC
	LD	(IX+-4),HL
;  417			Data = *VideoMemTmp++;
	LD	HL,(_VideoMemTmp)
	LD	A,(HL)
	LD	(IX+-1),A
	LD	BC,(_VideoMemTmp)
	INC	BC
	LD	(_VideoMemTmp),BC
;  418			
;  419			while(NumData-- > 0)
	JR	L_54
L_55:
;  420				PutPcxPixel(Data);
	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	CALL	_PutPcxPixel
	POP	BC
L_54:
	LD	BC,(IX+-7)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	LD	IY,(IX+-7)
	LEA	IY,IY+-1
	LD	(IX+-7),IY
	JR	C,L_55
;  421		}
L_56:
	LD	BC,(IX+-4)
	LD	HL,(IX+-10)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_57
;  422	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _DecodePcxFile ***************************
;Name                         Addr/Register   Size   Type
;_PutPcxPixel                        IMPORT  -----   function
;_VideoMemTmp                        STATIC      3   variable
;_YSize                              STATIC      2   variable
;_XSize                              STATIC      2   variable
;tmp                                  IX-10      3   variable
;NumData                               IX-7      3   variable
;fsize                                 IX-4      3   variable
;Data                                  IX-1      1   variable


; Stack Frame Size: 19 (bytes)
;       Spill Code: 0 (instruction)


;  423	
;  424	//Put image pixel on screen
;  425	void PutPcxPixel(unsigned char Px)
;  426	{
_PutPcxPixel:
	CALL	__frameset0
;  427		VideoMem[YOffset[PosY + StartY] + (PosX + StartX)] = Px;
	LD	BC,(_PosY)
	CALL	__stoi
	LD	DE,HL
	LD	BC,(_StartY)
	CALL	__stoi
	ADD	HL,DE
	LD	BC,HL
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	OR	A,A
	SBC	HL,BC
	LD	BC,_YOffset
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(_PosX)
	CALL	__stoi
	LD	DE,HL
	LD	BC,(_StartX)
	CALL	__stoi
	ADD	HL,DE
	LD	BC,(IY)
	ADD	HL,BC
	LD	BC,(_VideoMem)
	ADD	HL,BC
	LD	A,(IX+6)
	LD	(HL),A
;  428		
;  429		PosX++;
	LD	BC,(_PosX)
	INC	BC
	LD	HL,_PosX
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  430		
;  431		if (PosX >= XSize)
	LD	BC,(_XSize)
	LD	HL,(_PosX)
	OR	A,A
	SBC.SIS	HL,BC
	JP	M,L__63
	JP	PE,L_62
	JR	L__64
L__63:
	JP	PO,L_62
L__64:
;  432		{
;  433			PosX = 0;
	LD	HL,_PosX
	LD	(HL),0
	INC	HL
	LD	(HL),0
;  434			PosY++;
	LD	BC,(_PosY)
	INC	BC
	LD	HL,_PosY
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  435		}
;  436	}
L_62:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _PutPcxPixel ***************************
;Name                         Addr/Register   Size   Type
;_XSize                              STATIC      2   variable
;_StartX                             STATIC      2   variable
;_PosX                               STATIC      2   variable
;_StartY                             STATIC      2   variable
;_PosY                               STATIC      2   variable
;_YOffset                            STATIC   1440   variable
;_VideoMem                           STATIC      3   variable
;Px                                    IX+6      1   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  437	
;  438	void BuildOffset(void)
;  439	{
_BuildOffset:
	LD	HL,-2
	CALL	__frameset
	LD	(IX+-2),0
	LD	(IX+-1),0
;  440		short i;
;  441		
;  442		for (i = 0; i < VideoY; i++)
	JR	L_66
L_64:
;  443			YOffset[i] = (unsigned int)i * (unsigned int)VideoX;
	LD	BC,(_VideoX)
	CALL	__stoi
	LD	DE,HL
	LD	BC,(IX+-2)
	CALL	__stoi
	LD	BC,HL
	LD	HL,DE
	CALL	__imulu
	LD	DE,HL
	LD	BC,(IX+-2)
	CALL	__stoi
	LD	BC,HL
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	OR	A,A
	SBC	HL,BC
	LD	BC,_YOffset
	ADD	HL,BC
	LD	(HL),DE
	LD	HL,(IX+-2)
	INC	HL
	LD	(IX+-2),L
	LD	(IX+-1),H
L_66:
	LD	BC,(_VideoY)
	LD	HL,(IX+-2)
	OR	A,A
	SBC.SIS	HL,BC
	JP	M,L__67
	JP	PE,L_64
	JR	L__68
L__67:
	JP	PO,L_64
L__68:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _BuildOffset ***************************
;Name                         Addr/Register   Size   Type
;_VideoY                             STATIC      2   variable
;_YOffset                            STATIC   1440   variable
;_VideoX                             STATIC      2   variable
;i                                     IX-2      2   variable


; Stack Frame Size: 8 (bytes)
;       Spill Code: 0 (instruction)


	XREF _memcpy:ROM
	XREF __idivs:ROM
	XREF __idivu:ROM
	XREF __imulu:ROM
	XREF __iremu:ROM
	XREF __stoi:ROM
	XREF __frameset0:ROM
	XREF __frameset:ROM
	XREF __ishl_b:ROM
	XDEF _BuildOffset
	XDEF _PutPcxPixel
	XDEF _DecodePcxFile
	XDEF _Set_640_480_Mode
	XDEF _Set_320_240_Mode
	XDEF _LoadPcxFile
	XDEF _LoadPcxPalette
	XDEF _ShowMsg
	XDEF _uitoa
	XDEF _Make_Short
	XDEF _main
	XDEF _YOffset
	XDEF _PntPal
	XDEF _TmpPal
	XDEF _PcxPalette
	XDEF _PosY
	XDEF _PosX
	XDEF _VideoY
	XDEF _VideoX
	XDEF _StartY
	XDEF _StartX
	XDEF _YSize
	XDEF _XSize
	XDEF _MaxY
	XDEF _MaxX
	XDEF _MinY
	XDEF _MinX
	XDEF _convBuf
	XDEF _VideoMemTmp
	XDEF _VideoMem
	XDEF _PntHeader
	END
