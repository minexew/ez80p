; Zilog eZ80 ANSI C Compiler Release 3.3
; -nomodsect -optspeed -noreduceopt -peephole -globalopt
; -localcse -const=ROM 
	FILE	"..\MAIN.C"
	.assume ADL=1
	SEGMENT BSS
_tebuflen:
	DS	3
_tebuf:
	DS	2058
_scn_virt:
	DS	4000
_scn_phys:
	DS	4000
_backbuffer:
	DS	320
_root:
	DS	9
_p_root:
	DS	3
_p_curr:
	DS	3
_numlines:
	DS	3
_cur_line:
	DS	3
_cur_char:
	DS	3
_cur_row:
	DS	3
_cur_col:
	DS	3
_linbuf:
	DS	90
_Ascii:
	DS	1
_Scancode:
	DS	1
_B:
	DS	1
_C:
	DS	1
_E:
	DS	1
_InsertMode:
	DS	1
_K_xHL:
	DS	3
_K_xBC:
	DS	3
_filesize:
	DS	3
	SEGMENT DATA
_BufferFile:
	DW24	12582912
	SEGMENT BSS
_TxtPnt:
	DS	3
	SEGMENT STRSECT
L__0:
	DB	"noname.txt"
	DB	0
	SEGMENT DATA
_NonameFile:
	DW24	L__0
	SEGMENT BSS
_UseFile:
	DS	1
_convBuf:
	DS	5
;    1	/*
;    2		PROTED: PROse Text eDitor
;    3		
;    4		coded by Calogiuri Enzo Antonio for PROSE community.	
;    5	*/
;    6	
;    7	#include <stdio.h>
;    8	#include <stdlib.h>
;    9	#include <string.h>
;   10	#include <stddef.h>
;   11	
;   12	#include "PROSE_Header.h"
;   13	
;   14	#define TEBUFMAX		2048					/* Bytes in the terminal package output buffer.        */
;   15	#define MAXLNLEN		80						/* Maximum line length this editor can handle.         */
;   16	#define SCNROWS			50						/* Number of rows    in target terminal.               */
;   17	#define SCNCOLS			80						/* Number of columns in target terminal.               */
;   18	#define VERSION			"1.1"					/* Version number of this editor.                      */
;   19	#define FUDGE			10
;   20	#define FALSE			0
;   21	#define TRUE			1
;   22	#define SCNSIZE 		(SCNROWS * SCNCOLS)
;   23	
;   24	#define EOS 			'\0'
;   25	#define EOL 			'\n'
;   26	#define CH_TAB 			9
;   27	
;   28	int tebuflen;
;   29	static char tebuf[TEBUFMAX + FUDGE];
;   30	char scn_virt[SCNROWS][SCNCOLS];
;   31	char scn_phys[SCNROWS][SCNCOLS];
;   32	char backbuffer[4][SCNCOLS];
;   33	
;   34	typedef struct line_t_ line_t;
;   35	#define p_line_t line_t *
;   36	struct line_t_
;   37	 {
;   38	   p_line_t 	p_prev;						/* Pointer to the previous line record.                  */
;   39	   p_line_t 	p_next;						/* Pointer to the next     line record.                  */
;   40	   char   		*p_data; 					/* Pointer to the line itself (C string in heap).        */
;   41	 };
;   42	 
;   43	line_t root;								/* The root line (unused as a line).               */
;   44	p_line_t p_root;							/* Pointer to the root line.                       */
;   45	p_line_t p_curr;							/* Ptr to the current line (or root if at EOF).    */
;   46	int numlines, cur_line, cur_char, cur_row, cur_col;
;   47	char linbuf[MAXLNLEN+FUDGE]; 
;   48	
;   49	static unsigned char Ascii, Scancode, B, C, E, InsertMode;
;   50	unsigned int K_xHL, K_xBC, filesize;
;   51	char *BufferFile = (char *)0x0C00000;		/* Use VGA Ram B to load or save file      */
;   52	static char *TxtPnt;
;   53	static char *NonameFile = "noname.txt";
;   54	char UseFile;
;   55	
;   56	void GetCh(void);
;   57	unsigned char getch(void);
;   58	void print(const char *Txt);
;   59	void get_cursor_position(unsigned char *X, unsigned char *Y);
;   60	void plot_char(unsigned char x, unsigned char y, unsigned char Ch);
;   61	void clreol(void);
;   62	void gotoxy(unsigned char x, unsigned char y);
;   63	int get_prose_version(void);
;   64	void get_display_size(void);
;   65	
;   66	void uitoa(unsigned int val, char *string);
;   67	char convBuf[5];
	SEGMENT CODE
;   68	
;   69	void ShowMenu(void);
;   70	void ShowInsertMode(void);
;   71	void Enable_Back_Color(void);
;   72	void Disable_Back_Color(void);
;   73	void Show_Cursor(void);
;   74	void Show_Cursor_Position(void);
;   75	
;   76	char FileExists(void);
;   77	void load_file(void);
;   78	void save_file(void);
;   79	void reload_file(void);
;   80	
;   81	void msg_window(char *msg1, char *msg2);
;   82	void close_msg_window(void);
;   83	
;   84	/*-------------------------------------------------------------------------*/
;   85	
;   86	void bomb(char *txt);
;   87	void as(char b, char *txt);
;   88	void *mymalloc(size_t n);
;   89	char blankrow(char *p);
;   90	void zap_trail(char *s);
;   91	void purify(char *st);
;   92	void te_flu(void);
;   93	unsigned char te_gch(void);
;   94	void te_chr(char ch);
;   95	void te_str(char *s);
;   96	void te_mov(unsigned char r, unsigned char c);
;   97	void te_cln(unsigned char row);
;   98	void te_clr(void);
;   99	void te_ini(void);
;  100	void te_fin(void);
;  101	
;  102	void sc_clr(void);
;  103	void sc_crw(unsigned char row);
;  104	void sc_chr(unsigned char row, unsigned char col, unsigned char ch);
;  105	void sc_str(unsigned char row, unsigned char col, char *s);
;  106	void sc_upd(void);
;  107	void sc_fup(void);
;  108	void sc_ini(void);
;  109	void sc_fin(void);
;  110	
;  111	void tx_ini(void);
;  112	void tx_set(p_line_t p_line, char *s);
;  113	void tx_ins(p_line_t p_line, char *s);
;  114	void tx_del(p_line_t p_line);
;  115	void tx_get(p_line_t p_line);
;  116	void tx_put(p_line_t p_line);
;  117	
;  118	void do_red(void);
;  119	void do_cup(void);
;  120	void do_cdw(void);
;  121	void do_clf(void);
;  122	void do_crt(void);
;  123	void do_pdw(void);
;  124	void do_pup(void);
;  125	void do_ret(void);
;  126	void do_enhanced_ret(void);
;  127	void do_tab(void);
;  128	void do_top(void);
;  129	void do_bot(char paint);
;  130	void do_chr(char ch);
;  131	void do_dch(void);
;  132	void do_iln(void);
;  133	void do_dln(void);
;  134	void do_del(void);
;  135	void do_enhanced_del(void);
;  136	void do_home(void);
;  137	void do_endline(void);
;  138	void do_ins(void);
;  139	
;  140	void paintall(void);
;  141	void paintrow(void);
;  142	
;  143	void edit(void);
;  144	
;  145	/*-------------------------------------------------------------------------*/
;  146	void main(void)
;  147	{
_main:
;  148		INIT_HARDWARE;
PB_DR		equ 09Ah
PB_DDR		equ 09Bh
PB_ALT1		equ 09Ch
PB_ALT2		equ 09Dh
PC_DR		equ 09Eh
PC_DDR		equ 09Fh
PC_ALT1		equ 0A0h
PC_ALT2		equ 0A1h
PD_DR		equ 0A2h
PD_DDR		equ 0A3h
PD_ALT1		equ 0A4h
PD_ALT2		equ 0A5h
UART0_RBR	equ 0C0h
UART0_THR	equ 0C0h
UART0_BRG_L	equ 0C0h
UART0_BRG_H	equ 0C1h
UART0_IER	equ 0C1h
UART0_FCTL	equ 0C2h
UART0_LCTL	equ 0C3h
UART0_MCTL	equ 0C4h
UART0_LSR	equ 0C5h
UART0_MSR	equ 0C6h
CS0_LBR		equ 0A8h
CS0_UBR		equ 0A9h
CS0_CTL		equ 0AAh
CS1_LBR		equ 0ABh
CS1_UBR		equ 0ACh
CS1_CTL		equ 0ADh
CS2_LBR		equ 0AEh
CS2_UBR		equ 0AFh
CS2_CTL		equ 0B0h
CS3_LBR		equ 0B1h
CS3_UBR		equ 0B2h
CS3_CTL		equ 0B3h
TMR0_CTL		equ 080h
TMR0_DR_L	equ 081h
TMR0_RR_L	equ 081h
TMR0_DR_H	equ 082h
TMR0_RR_H	equ 082h
TMR_ISS		equ 092h
RTC_CTRL		equ 0EDh
RTC_ACTRL	equ 0ECh
RTC_SEC		equ 0E0h
RTC_MIN		equ 0E1h
RTC_HRS		equ 0E2h
RTC_DOW		equ 0E3h
RTC_DOM		equ 0E4h
RTC_MON		equ 0E5h
RTC_YR		equ 0E6h
RTC_CEN		equ 0E7h
port_pic_data		equ 000h
port_pic_ctrl		equ 001h
port_hw_flags		equ 001h
port_sdc_ctrl		equ 002h
port_keyboard_data	equ 002h
port_sdc_data		equ 003h
port_memory_paging	equ 004h
port_irq_ctrl		equ 005h
port_nmi_ack			equ 006h
port_ps2_ctrl		equ 007h
port_selector		equ 008h
port_mouse_data		equ 006h
port_clear_flags		equ 009h
sdc_power			equ 0h
sdc_cs				equ 1h
sdc_speed			equ 2h
sdc_serializer_busy	equ 4h
vrt					equ 5h
sysram_addr			equ 0000000h
vram_a_addr			equ 0800000h
vram_b_addr			equ 0C00000h
hw_palette			equ 0ff0000h
hw_sprite_registers	equ 0ff0800h
hw_video_parameters	equ 0ff1000h
hw_audio_registers	equ 0ff1400h
hw_video_settings	equ 0ff1800h
tilemap_parameters	equ hw_video_parameters + 00h
bitmap_parameters	equ hw_video_parameters + 20h
video_control		equ hw_video_settings + 00h
sprite_control		equ hw_video_settings + 01h
bgnd_palette_select	equ hw_video_settings + 02h
sprite_palette_select	equ hw_video_settings + 03h
right_border_position	equ hw_video_settings + 04h
os_start			equ 0A00h
prose_return		equ os_start + 14h
prose_kernal		equ os_start + 20h
;  149		INIT_KJT;
kr_mount_volumes			equ 00h
kr_get_device_info		equ 01h
kr_check_volume_format	equ 02h
kr_change_volume			equ 03h
kr_get_volume_info		equ 04h
kr_format_device			equ 05h
kr_make_dir				equ 06h
kr_change_dir			equ 07h
kr_parent_dir			equ 08h
kr_root_dir				equ 09h
kr_delete_dir			equ 0Ah
kr_find_file				equ 0Bh
kr_set_file_pointer		equ 0Ch
kr_set_load_length		equ 0Dh
kr_read_file				equ 0Eh
kr_erase_file			equ 0Fh
kr_rename_file			equ 10h
kr_create_file			equ 11h
kr_write_file			equ 12h
kr_get_total_sectors		equ 13h
kr_dir_list_first_entry	equ 14h
kr_dir_list_get_entry	equ 15h
kr_dir_list_next_entry	equ 16h
kr_read_sector			equ 17h
kr_write_sector			equ 18h
kr_file_sector_list		equ 19h
kr_get_dir_cluster		equ 1Ah
kr_set_dir_cluster		equ 1Bh
kr_get_dir_name			equ 1Ch
kr_wait_key				equ 1Dh
kr_get_key				equ 1Eh
kr_get_key_mod_flags		equ 1Fh
kr_serial_receive_header	equ 20h
kr_serial_receive_file	equ 21h
kr_serial_send_file		equ 22h
kr_serial_tx_byte		equ 23h
kr_serial_rx_byte		equ 24h
kr_print_string			equ 25h
kr_clear_screen			equ 26h
kr_wait_vrt				equ 27h
kr_set_cursor_position	equ 28h
kr_plot_char				equ 29h
kr_set_pen				equ 2Ah
kr_background_colours	equ 2Bh
kr_draw_cursor			equ 2Ch
kr_get_pen				equ 2Dh
kr_scroll_up				equ 2Eh
kr_os_display			equ 2Fh
kr_get_display_size		equ 30h
kr_get_charmap_addr_xy	equ 31h
kr_get_cursor_position	equ 32h
kr_set_envar				equ 33h
kr_get_envar				equ 34h
kr_delete_envar			equ 35h
kr_set_mouse_window		equ 36h
kr_get_mouse_position	equ 37h
kr_get_mouse_motion		equ 38h
kr_time_delay			equ 39h
kr_compare_strings		equ 3Ah
kr_hex_byte_to_ascii		equ 3Bh
kr_ascii_to_hex_word		equ 3Ch
kr_get_string			equ 3Dh
kr_get_version			equ 3Eh
kr_dont_store_registers	equ 3Fh
kr_get_font_info			equ 40h
kr_read_rtc				equ 41h
kr_write_rtc				equ 42h
kr_get_keymap_location	equ 43h
;  150		
;  151		CREATE_HEADER;
jr skip_header
db 'PRO'
mb_loc dw24 10000h
dw24 0
dw 0
dw 0
db 1
skip_header
;  152		
;  153		UseFile = 0;	
	XOR	A,A
	LD	(_UseFile),A
;  154		
;  155		asm ("ld a, (hl)");
ld a, (hl)
;  156		asm ("or a");
or a
;  157		asm ("jr z, no_param");
jr z, no_param
;  158		asm ("ld (_K_xHL), hl");	//If parameter passed, save the position in K_xHL
ld (_K_xHL), hl
;  159		
;  160		UseFile = 1;
	LD	A,1
	LD	(_UseFile),A
;  161		
;  162		asm ("no_param:");
no_param:
;  163		
;  164		if (get_prose_version() < 0x2F)
	CALL	_get_prose_version
	LD	BC,47
	OR	A,A
	SBC	HL,BC
	JP	P,L__15
	JP	PE,L_1
	JR	L__16
L__15:
	JP	PO,L_1
L__16:
;  165		{
;  166			print("Proted require PROSE ver 2F or later!\n\r");
	LD	BC,L__2
	PUSH	BC
	CALL	_print
	POP	BC
;  167			
;  168			QUIT_TO_PROSE;
xor a
jp.lil prose_return
;  169			
;  170			return;
	JR	L_8
;  171		}
L_1:
;  172		
;  173		get_display_size();
	CALL	_get_display_size
;  174		
;  175		if (!((B == 80) && (C == 60)))
	LD	A,(_B)
	CP	A,80
	JR	NZ,L_3
	LD	A,(_C)
	CP	A,60
	JR	Z,L_4
L_3:
;  176		{
;  177			print("Proted require 80x60 characters mode (VMODE 0)!\n\r");
	LD	BC,L__5
	PUSH	BC
	CALL	_print
	POP	BC
;  178			
;  179			QUIT_TO_PROSE;
xor a
jp.lil prose_return
;  180			
;  181			return;
	JR	L_8
;  182		}
L_4:
;  183		
;  184		asm ("push ix");
push ix
;  185		asm ("ld a, kr_clear_screen");
ld a, kr_clear_screen
;  186		asm ("call.lil prose_kernal");
call.lil prose_kernal
;  187		asm ("pop ix");
pop ix
;  188		
;  189		memset(BufferFile, 0, 1024 * 512);	
	LD	BC,524288
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,(_BufferFile)
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  190		
;  191		ShowMenu();
	CALL	_ShowMenu
;  192		
;  193		te_ini();
	CALL	_te_ini
;  194		sc_ini();
	CALL	_sc_ini
;  195		tx_ini();
	CALL	_tx_ini
;  196		
;  197		if (UseFile == 1)
	LD	A,(_UseFile)
	CP	A,1
	JR	NZ,L_7
;  198			if (FileExists() == 1)
	CALL	_FileExists
	LD	B,A
	SEXT	HL
	LD	L,B
	OR	A,A
	LD	BC,1
	SBC	HL,BC
	JR	NZ,L_7
;  199				load_file();		
	CALL	_load_file
L_7:
;  200		
;  201		edit();
	CALL	_edit
;  202		
;  203		sc_fin();
	CALL	_sc_fin
;  204		te_fin();
	CALL	_te_fin
;  205		
;  206		asm ("proted_exit:");
proted_exit:
;  207		asm ("push ix");
push ix
;  208		asm ("ld a, kr_clear_screen");
ld a, kr_clear_screen
;  209		asm ("call.lil prose_kernal");
call.lil prose_kernal
;  210		asm ("pop ix");
pop ix
;  211		
;  212		print("\n\r");
	LD	BC,L__8
	PUSH	BC
	CALL	_print
	POP	BC
;  213		print("PROTED ver ");
	LD	BC,L__9
	PUSH	BC
	CALL	_print
	POP	BC
;  214		print(VERSION);
	LD	BC,L__10
	PUSH	BC
	CALL	_print
	POP	BC
;  215		print(" rel.: ");
	LD	BC,L__11
	PUSH	BC
	CALL	_print
	POP	BC
;  216		print(__DATE__);
	LD	BC,L__12
	PUSH	BC
	CALL	_print
	POP	BC
;  217		print("\n\r");
	LD	BC,L__13
	PUSH	BC
	CALL	_print
	POP	BC
;  218		print("Created by Calogiuri Enzo Antonio for eZ80P fans :-)\n\r");	
	LD	BC,L__14
	PUSH	BC
	CALL	_print
	POP	BC
;  219		
;  220		QUIT_TO_PROSE;
xor a
jp.lil prose_return
;  221	}
L_8:
	RET	


;**************************** _main ***************************
;Name                         Addr/Register   Size   Type
;_te_fin                             IMPORT  -----   function
;_sc_fin                             IMPORT  -----   function
;_edit                               IMPORT  -----   function
;_load_file                          IMPORT  -----   function
;_FileExists                         IMPORT  -----   function
;_tx_ini                             IMPORT  -----   function
;_sc_ini                             IMPORT  -----   function
;_te_ini                             IMPORT  -----   function
;_ShowMenu                           IMPORT  -----   function
;_BufferFile                         STATIC      3   variable
;_memset                             IMPORT  -----   function
;_C                                  STATIC      1   variable
;_B                                  STATIC      1   variable
;_get_display_size                   IMPORT  -----   function
;_print                              IMPORT  -----   function
;_get_prose_version                  IMPORT  -----   function
;_UseFile                            STATIC      1   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__2:
	DB	"Proted require PROSE ver 2F or later!"
	DB	10,13,0
L__5:
	DB	"Proted require 80x60 characters mode (VMODE 0)!"
	DB	10,13,0
L__8:
	DB	10,13,0
L__9:
	DB	"PROTED ver "
	DB	0
L__10:
	DB	"1.1"
	DB	0
L__11:
	DB	" rel.: "
	DB	0
L__12:
	DB	"Jul 21 2011"
	DB	0
L__13:
	DB	10,13,0
L__14:
	DB	"Created by Calogiuri Enzo Antonio for eZ80P fans :-)"
	DB	10,13,0
	SEGMENT CODE
;  222	
;  223	/* Get ascii and scancode value of key pressed */
;  224	void GetCh(void)
;  225	{
_GetCh:
;  226		Ascii = Scancode = 0;
	XOR	A,A
	LD	(_Scancode),A
	XOR	A,A
	LD	(_Ascii),A
;  227		
;  228		asm ("push ix");
push ix
;  229		asm ("ld a, kr_get_key");
ld a, kr_get_key
;  230		asm ("call.lil prose_kernal");
call.lil prose_kernal
;  231		asm ("jr nz, NoKeyInB");
jr nz, NoKeyInB
;  232		asm ("ld (_Scancode), a");
ld (_Scancode), a
;  233		asm ("ld a, b");
ld a, b
;  234		asm ("ld (_Ascii), a");
ld (_Ascii), a
;  235		asm ("NoKeyInB:");
NoKeyInB:
;  236		asm ("pop ix");
pop ix
;  237	}
	RET	


;**************************** _GetCh ***************************
;Name                         Addr/Register   Size   Type
;_Ascii                              STATIC      1   variable
;_Scancode                           STATIC      1   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


;  238	
;  239	/* Manage the input from keyboard */
;  240	unsigned char getch(void)
;  241	{
_getch:
;  242		while (1)
L_30:
;  243		{	
;  244			GetCh();	
	CALL	_GetCh
;  245			
;  246			switch (Scancode)
	LD	A,(_Scancode)
	UEXT	HL
	LD	L,A
	LD	BC,HL
L__20:
	LD	DE,90
	OR	A,A
	SBC	HL,DE
	JR	Z,L_15
	LD	HL,90
	OR	A,A
	SBC	HL,BC
	JR	C,L__22
	LD	DE,18
	LD	HL,BC
	OR	A,A
	SBC	HL,DE
	JR	Z,L_17
	LD	HL,18
	OR	A,A
	SBC	HL,BC
	JR	C,L_28
	LD	DE,13
	LD	HL,BC
	OR	A,A
	SBC	HL,DE
	JR	Z,L_14
	JR	L_28
L__22:
	LD	DE,105
	LD	HL,BC
	OR	A,A
	SBC	HL,DE
	JR	C,L__26
	LD	HL,125
	OR	A,A
	SBC	HL,BC
	JR	C,L_28
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	OR	A,A
	SBC	HL,BC
	LD	DE,L__19-315
	ADD	HL,DE
	LD	HL,(HL)
	JP	(HL)
L__19:
	DW24	L_24	

	DW24	L_28	

	DW24	L_20	

	DW24	L_23	

	DW24	L_28	

	DW24	L_28	

	DW24	L_28	

	DW24	L_25	

	DW24	L_11	

	DW24	L_22	

	DW24	L_28	

	DW24	L_26	

	DW24	L_21	

	DW24	L_28	

	DW24	L_28	

	DW24	L_28	

	DW24	L_28	

	DW24	L_12	

	DW24	L_28	

	DW24	L_28	

	DW24	L_10	

L__26:
	LD	DE,102
	LD	HL,BC
	OR	A,A
	SBC	HL,DE
	JR	Z,L_13
	JR	L_28
;  247			{
;  248				case 0x7D	: Ascii = 3; break;
L_10:
	LD	A,3
	LD	(_Ascii),A
	JR	L_28
;  249				
;  250				case 0x71	: Ascii = 4; break;	
L_11:
	LD	A,4
	LD	(_Ascii),A
	JR	L_28
;  251	
;  252				case 0x7A	: Ascii = 6; break;
L_12:
	LD	A,6
	LD	(_Ascii),A
	JR	L_28
;  253				
;  254				case 102	: Ascii = 8; break;
L_13:
	LD	A,8
	LD	(_Ascii),A
	JR	L_28
;  255				
;  256				case 0xD	: Ascii = 9; break;			
L_14:
	LD	A,9
	LD	(_Ascii),A
	JR	L_28
;  257				
;  258				case 90		: Ascii = 13; break;			
L_15:
	LD	A,13
	LD	(_Ascii),A
	JR	L_28
;  259				
;  260				case 0x12	: while (Ascii == 0)
L_18:
;  261								GetCh();
	CALL	_GetCh
L_17:
	LD	A,(_Ascii)
	OR	A,A
	JR	Z,L_18
;  262								
;  263							  break;
	JR	L_28
;  264				
;  265				case 0x6B	:
L_20:
;  266				case 0x75	:
L_21:
;  267				case 0x72	:
L_22:
;  268				case 0x6C	:
L_23:
;  269				case 0x69	:
L_24:
;  270				case 0x70	:
L_25:
;  271				case 0x74	: Ascii = 1; break;
L_26:
	LD	A,1
	LD	(_Ascii),A
;  272			}
L_28:
;  273			
;  274			if (Ascii != 0)
	LD	A,(_Ascii)
	OR	A,A
	JR	Z,L_30
;  275				break;		
;  276		}	
;  277			
;  278		return Ascii;
	LD	A,(_Ascii)
;  279	}
	RET	


;**************************** _getch ***************************
;Name                         Addr/Register   Size   Type
;_Ascii                              STATIC      1   variable
;_Scancode                           STATIC      1   variable
;_GetCh                              IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


;  280	
;  281	/* Print on screen a text at current x,y position */
;  282	void print(const char *Txt)
;  283	{
_print:
	CALL	__frameset0
;  284		TxtPnt = Txt;
	LD	BC,(IX+6)
	LD	(_TxtPnt),BC
;  285		
;  286		asm ("push ix");
push ix
;  287		asm ("ld hl, (_TxtPnt)");
ld hl, (_TxtPnt)
;  288		asm ("ld a, kr_print_string");
ld a, kr_print_string
;  289		asm ("call.lil prose_kernal");
call.lil prose_kernal
;  290		asm ("pop ix");
pop ix
;  291	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _print ***************************
;Name                         Addr/Register   Size   Type
;_TxtPnt                             STATIC      3   variable
;Txt                                   IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  292	
;  293	/* Get the x and the y of screen cursor */
;  294	void get_cursor_position(unsigned char *X, unsigned char *Y)
;  295	{
_get_cursor_position:
	CALL	__frameset0
;  296		asm ("push ix");
push ix
;  297		asm ("ld a, kr_get_cursor_position");
ld a, kr_get_cursor_position
;  298		asm ("call.lil prose_kernal");
call.lil prose_kernal
;  299		asm ("ld a, b");
ld a, b
;  300		asm ("ld (_B), a");
ld (_B), a
;  301		asm ("ld a, c");
ld a, c
;  302		asm ("ld (_C), a");
ld (_C), a
;  303		asm ("pop ix");
pop ix
;  304		
;  305		*X = B;
	LD	HL,(IX+6)
	LD	A,(_B)
	LD	(HL),A
;  306		*Y = C;
	LD	HL,(IX+9)
	LD	A,(_C)
	LD	(HL),A
;  307	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _get_cursor_position ***************************
;Name                         Addr/Register   Size   Type
;_C                                  STATIC      1   variable
;_B                                  STATIC      1   variable
;Y                                     IX+9      3   parameter
;X                                     IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


;  308	
;  309	/* Draw a character at X, Y coordinates */
;  310	void plot_char(unsigned char x, unsigned char y, unsigned char Ch)
;  311	{
_plot_char:
	CALL	__frameset0
;  312		B = x;
	LD	A,(IX+6)
	LD	(_B),A
;  313		C = y;
	LD	A,(IX+9)
	LD	(_C),A
;  314		E = Ch;
	LD	A,(IX+12)
	LD	(_E),A
;  315		
;  316		asm ("push ix");
push ix
;  317		asm ("ld hl, _B");
ld hl, _B
;  318		asm ("ld B, (hl)");
ld B, (hl)
;  319		asm ("ld hl, _C");
ld hl, _C
;  320		asm ("ld C, (hl)");
ld C, (hl)
;  321		asm ("ld hl, _E");
ld hl, _E
;  322		asm ("ld E, (hl)");
ld E, (hl)
;  323		asm ("ld a, kr_plot_char");
ld a, kr_plot_char
;  324		asm ("call.lil prose_kernal");
call.lil prose_kernal
;  325		asm ("pop ix");
pop ix
;  326	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _plot_char ***************************
;Name                         Addr/Register   Size   Type
;_E                                  STATIC      1   variable
;_C                                  STATIC      1   variable
;_B                                  STATIC      1   variable
;Ch                                   IX+12      1   parameter
;y                                     IX+9      1   parameter
;x                                     IX+6      1   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: 0 (instruction)


;  327	
;  328	/* Clear the row on screen from current x,y position */
;  329	void clreol(void)
;  330	{
_clreol:
	LD	HL,-3
	CALL	__frameset
;  331		unsigned char x, y;
;  332		register char i;
;  333		
;  334		get_cursor_position(&x, &y);
	PEA	IX+-2
	PEA	IX+-3
	CALL	_get_cursor_position
	POP	BC
	POP	BC
	LD	A,(IX+-3)
	LD	(IX+-1),A
;  335		
;  336		for (i = x; i < 80; i++)
	JR	L_39
L_37:
;  337			plot_char(i, y, ' ');		
	LD	BC,32
	PUSH	BC
	LD	C,(IX+-2)
	LD	B,0
	PUSH	BC
	LD	C,(IX+-1)
	PUSH	BC
	CALL	_plot_char
	POP	BC
	POP	BC
	POP	BC
	INC	(IX+-1)
L_39:
	LD	A,(IX+-1)
	CP	A,80
	JP	M,L_37
;  338	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _clreol ***************************
;Name                         Addr/Register   Size   Type
;_plot_char                          IMPORT  -----   function
;_get_cursor_position                IMPORT  -----   function
;x                                     IX-3      1   variable
;y                                     IX-2      1   variable
;i                                     IX-1      1   variable


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  339	
;  340	/* Move screen cursor at x,y position */
;  341	void gotoxy(unsigned char x, unsigned char y)
;  342	{
_gotoxy:
	CALL	__frameset0
;  343		B = x;
	LD	A,(IX+6)
	LD	(_B),A
;  344		C = y;
	LD	A,(IX+9)
	LD	(_C),A
;  345		
;  346		asm ("push ix");
push ix
;  347		asm ("ld hl, _B");
ld hl, _B
;  348		asm ("ld B, (hl)");
ld B, (hl)
;  349		asm ("ld hl, _C");
ld hl, _C
;  350		asm ("ld C, (hl)");
ld C, (hl)
;  351		asm ("ld a, kr_set_cursor_position");
ld a, kr_set_cursor_position
;  352		asm ("call.lil prose_kernal");
call.lil prose_kernal
;  353		asm ("pop ix");
pop ix
;  354	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _gotoxy ***************************
;Name                         Addr/Register   Size   Type
;_C                                  STATIC      1   variable
;_B                                  STATIC      1   variable
;y                                     IX+9      1   parameter
;x                                     IX+6      1   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


;  355	
;  356	/* Return only PROSE version */
;  357	int get_prose_version(void)
;  358	{
_get_prose_version:
;  359		asm ("push ix");
push ix
;  360		asm ("push de");
push de
;  361		asm ("push hl");
push hl
;  362		asm ("ld a, kr_get_version");
ld a, kr_get_version
;  363		asm ("call.lil prose_kernal");
call.lil prose_kernal
;  364		asm ("ld (_K_xBC), hl");
ld (_K_xBC), hl
;  365		asm ("pop hl");
pop hl
;  366		asm ("pop de");
pop de
;  367		asm ("pop ix");
pop ix
;  368		
;  369		return K_xBC;
	LD	HL,(_K_xBC)
;  370	}
	RET	


;**************************** _get_prose_version ***************************
;Name                         Addr/Register   Size   Type
;_K_xBC                              STATIC      3   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


;  371	
;  372	/* Return PROSE screen dimension stored in B = Width, C = Height */
;  373	void get_display_size(void)
;  374	{
_get_display_size:
;  375		asm ("push ix");
push ix
;  376		asm ("ld a, kr_get_display_size");
ld a, kr_get_display_size
;  377		asm ("call.lil prose_kernal");
call.lil prose_kernal
;  378		asm ("ld a, b");
ld a, b
;  379		asm ("ld (_B), a");
ld (_B), a
;  380		asm ("ld a, c");
ld a, c
;  381		asm ("ld (_C), a");
ld (_C), a
;  382		asm ("pop ix");
pop ix
;  383	}
	RET	


;**************************** _get_display_size ***************************
;Name                         Addr/Register   Size   Type


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


;  384	
;  385	/*-------------------------------------------------------------------------*/
;  386	
;  387	/* Writes out its argument string and then halt the program. */
;  388	void bomb(char *txt)
;  389	{
_bomb:
	CALL	__frameset0
;  390		msg_window("Proted assertion failure. Press RETURN to abort!", txt);
	LD	BC,(IX+6)
	PUSH	BC
	LD	BC,L__40
	PUSH	BC
	CALL	_msg_window
	POP	BC
	POP	BC
;  391		
;  392		while (1)
L_46:
;  393		{
;  394			getch();
	CALL	_getch
;  395			
;  396			if (Ascii == 13)
	LD	A,(_Ascii)
	CP	A,13
	JR	NZ,L_46
;  397				break;
;  398		}
;  399	
;  400		asm ("ld a, 0ffh");
ld a, 0ffh
;  401		asm ("jp.lil prose_return");
jp.lil prose_return
;  402	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _bomb ***************************
;Name                         Addr/Register   Size   Type
;_Ascii                              STATIC      1   variable
;_getch                              IMPORT  -----   function
;_msg_window                         IMPORT  -----   function
;txt                                   IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__40:
	DB	"Proted assertion failure. Press RETURN to abort!"
	DB	0
	SEGMENT CODE
;  403	
;  404	/* Bombs with an assertion failure if its first argument is FALSE. */
;  405	void as(char b, char *txt)
;  406	{
_as:
	CALL	__frameset0
;  407		if (!b)
	LD	A,(IX+6)
	OR	A,A
	JR	NZ,L_50
;  408			bomb(txt);
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_bomb
	POP	BC
;  409	}
L_50:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _as ***************************
;Name                         Addr/Register   Size   Type
;_bomb                               IMPORT  -----   function
;txt                                   IX+9      3   parameter
;b                                     IX+6      1   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


;  410	
;  411	/* Convert an unsigned int into string */
;  412	void uitoa(unsigned int val, char *string)
;  413	{
_uitoa:
	LD	HL,-6
	CALL	__frameset
;  414		char index = 0, i = 0;
	LD	(IX+-1),0
	LD	(IX+-2),0
;  415		
;  416		do {
L_53:
;  417			string[index] = '0' + (val % 10);
	LD	A,(IX+-1)
	SEXT	HL
	LD	L,(IX+-1)
	LD	BC,(IX+9)
	ADD	HL,BC
	LD	(IX+-5),HL
	LD	HL,(IX+6)
	LD	BC,10
	CALL	__iremu
	LD	A,L
	ADD	A,48
	LD	HL,(IX+-5)
	LD	(HL),A
;  418			
;  419			if (string[index] > '9')
	LD	HL,(IX+-5)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,HL
	LD	HL,57
	OR	A,A
	SBC	HL,BC
	JP	P,L_52
;  420				string[index] += 'A' - '9' - 1;
	LD	HL,(IX+-5)
	LD	A,(HL)
	ADD	A,7
	LD	HL,(IX+-5)
	LD	(HL),A
L_52:
;  421			
;  422			val /= 10;
	LD	BC,10
	LD	HL,(IX+6)
	CALL	__idivu
	LD	(IX+6),HL
;  423			++index;
	INC	(IX+-1)
;  424	  } while (val != 0);
	LD	HL,(IX+6)
	OR	A,A
	LD	BC,0
	SBC	HL,BC
	JR	NZ,L_53
;  425	  
;  426	  string[index--] = '\0'; 
	LD	A,(IX+-1)
	SEXT	HL
	LD	L,(IX+-1)
	LD	BC,(IX+9)
	ADD	HL,BC
	LD	(HL),0
	DEC	(IX+-1)
;  427	  
;  428	  while (index > i)
	JR	L_57
L_58:
;  429	  {
;  430	    char tmp = string[i];
	LD	A,(IX+-2)
	SEXT	HL
	LD	L,(IX+-2)
	LD	BC,(IX+9)
	ADD	HL,BC
	LD	A,(HL)
	LD	(IX+-6),A
;  431		  
;  432	    string[i] = string[index];
	LD	A,(IX+-1)
	SEXT	HL
	LD	L,(IX+-1)
	LD	A,(IX+-2)
	LD	BC,(IX+9)
	ADD	HL,BC
	LD	IY,HL
	SEXT	HL
	LD	L,(IX+-2)
	LD	A,(IY)
	LD	BC,(IX+9)
	ADD	HL,BC
	LD	(HL),A
;  433	    string[index] = tmp;
	LD	A,(IX+-1)
	SEXT	HL
	LD	L,(IX+-1)
	LD	A,(IX+-6)
	LD	BC,(IX+9)
	ADD	HL,BC
	LD	(HL),A
;  434	    ++i;
	INC	(IX+-2)
;  435	    --index;
	DEC	(IX+-1)
;  436	  }
L_57:
	LD	A,(IX+-2)
	CP	A,(IX+-1)
	JP	M,L__48
	JP	PE,L_58
	JR	L__49
L__48:
	JP	PO,L_58
L__49:
;  437	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _uitoa ***************************
;Name                         Addr/Register   Size   Type
;tmp                                   IX-6      1   variable
;G_0                                   IX-5      3   variable
;i                                     IX-2      1   variable
;index                                 IX-1      1   variable
;string                                IX+9      3   parameter
;val                                   IX+6      3   parameter


; Stack Frame Size: 18 (bytes)
;       Spill Code: 0 (instruction)


;  438	
;  439	/* The same as malloc except it bombs if it cannot perform the allocation. */
;  440	void *mymalloc(size_t n)
;  441	{
_mymalloc:
	LD	HL,-3
	CALL	__frameset
;  442		void *p;
;  443		
;  444		if (n == 0)
	LD	BC,0
	LD	HL,(IX+6)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_62
;  445			n++;
	LD	BC,(IX+6)
	INC	BC
	LD	(IX+6),BC
L_62:
;  446		
;  447		p = malloc(n);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_malloc
	POP	BC
	LD	(IX+-3),HL
;  448		
;  449		as(p != NULL, "out of memory!");
	LD	BC,L__52
	PUSH	BC
	LD	HL,(IX+-3)
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	Z,L__54
	LD	A,1
	JR	L__55
L__54:
	XOR	A,A
L__55:
	LD	C,A
	LD	B,0
	PUSH	BC
	CALL	_as
	POP	BC
	POP	BC
;  450		
;  451		return p;
	LD	HL,(IX+-3)
;  452	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _mymalloc ***************************
;Name                         Addr/Register   Size   Type
;_as                                 IMPORT  -----   function
;_malloc                             IMPORT  -----   function
;p                                     IX-3      3   variable
;n                                     IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__52:
	DB	"out of memory!"
	DB	0
	SEGMENT CODE
;  453	
;  454	/* Returns TRUE if p[0..SCNCOLS - 1] are all blanks. */
;  455	char blankrow(char *p)
;  456	{
_blankrow:
	LD	HL,-1
	CALL	__frameset
	LD	(IX+-1),0
;  457		register unsigned char i;
;  458		
;  459		for (i = 0; i < SCNCOLS; i++)
	JR	L_68
L_66:
;  460			if (p[i] != ' ')
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+6)
	ADD	HL,BC
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	OR	A,A
	LD	BC,32
	SBC	HL,BC
	JR	Z,L_67
;  461				return FALSE;
	XOR	A,A
	JR	L_70
L_67:
	INC	(IX+-1)
L_68:
	LD	A,(IX+-1)
	CP	A,80
	JR	C,L_66
;  462			
;  463		return TRUE;
	LD	A,1
;  464	}
L_70:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _blankrow ***************************
;Name                         Addr/Register   Size   Type
;i                                     IX-1      1   variable
;p                                     IX+6      3   parameter


; Stack Frame Size: 10 (bytes)
;       Spill Code: 0 (instruction)


;  465	
;  466	/* Deletes trailing blanks from its argument string. */
;  467	void zap_trail(char *s)
;  468	{
_zap_trail:
	LD	HL,-3
	CALL	__frameset
;  469		char *p = s;
	LD	BC,(IX+6)
	LD	(IX+-3),BC
;  470		
;  471		while (*s != EOS)
	JR	L_74
L_75:
;  472		{
;  473			if (*s != ' ')
	LD	HL,(IX+6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	OR	A,A
	LD	BC,32
	SBC	HL,BC
	JR	Z,L_73
;  474				p = s + 1;
	LD	BC,(IX+6)
	INC	BC
	LD	(IX+-3),BC
L_73:
;  475			
;  476			s++;
	LD	BC,(IX+6)
	INC	BC
	LD	(IX+6),BC
;  477		}
L_74:
	LD	HL,(IX+6)
	LD	A,(HL)
	OR	A,A
	JR	NZ,L_75
;  478		
;  479		*p = EOS;
	LD	HL,(IX+-3)
	LD	(HL),0
;  480	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _zap_trail ***************************
;Name                         Addr/Register   Size   Type
;p                                     IX-3      3   variable
;s                                     IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


;  481	
;  482	/* Deletes all non-printables from the argument string. */
;  483	/* Replaces each TAB by a space.                        */
;  484	void purify(char *st)
;  485	{
_purify:
	LD	HL,-12
	CALL	__frameset
;  486		char *s = st;
	LD	BC,(IX+6)
	LD	(IX+-3),BC
;  487		char *d = st;
	LD	BC,(IX+6)
	LD	(IX+-6),BC
;  488		
;  489		while (*s)
	JR	L_86
L_87:
;  490		{
;  491			if ((' ' <= *s) && (*s <= '~'))
	LD	HL,(IX+-3)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	OR	A,A
	LD	BC,32
	SBC	HL,BC
	JP	M,L_83
	LD	HL,(IX+-3)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,HL
	LD	HL,126
	OR	A,A
	SBC	HL,BC
	JP	M,L__67
	JP	PE,L_83
	JR	L__68
L__67:
	JP	PO,L_83
L__68:
;  492				*d++ = *s;
	LD	BC,(IX+-6)
	LD	(IX+-9),BC
	LD	HL,(IX+-3)
	LD	A,(HL)
	LD	HL,(IX+-9)
	LD	(HL),A
	LD	BC,(IX+-6)
	INC	BC
	LD	(IX+-6),BC
L_83:
;  493			
;  494			if (*s == CH_TAB)		
	LD	HL,(IX+-3)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	OR	A,A
	LD	BC,9
	SBC	HL,BC
	JR	NZ,L_85
;  495				*d++ = ' ';
	LD	BC,(IX+-6)
	LD	(IX+-12),BC
	LD	HL,BC
	LD	(HL),32
	LD	BC,(IX+-6)
	INC	BC
	LD	(IX+-6),BC
L_85:
;  496			
;  497			s++;
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  498		}
L_86:
	LD	HL,(IX+-3)
	LD	A,(HL)
	OR	A,A
	JR	NZ,L_87
;  499		
;  500		*d = EOS;
	LD	HL,(IX+-6)
	LD	(HL),0
;  501	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _purify ***************************
;Name                         Addr/Register   Size   Type
;d                                     IX-6      3   variable
;s                                     IX-3      3   variable
;st                                    IX+6      3   parameter


; Stack Frame Size: 21 (bytes)
;       Spill Code: 0 (instruction)


;  502	
;  503	/* Flushes the terminal's output buffer tebuf to screen. */
;  504	void te_flu(void)
;  505	{
_te_flu:
;  506		if (tebuflen == 0)
	LD	BC,0
	LD	HL,(_tebuflen)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_92
;  507			return;
;  508		
;  509		tebuf[tebuflen] = EOS;
;  510		
;  511		print(tebuf);
	LD	BC,_tebuf
	PUSH	BC
	LD	HL,(_tebuflen)
	ADD	HL,BC
	LD	(HL),0
	CALL	_print
	POP	BC
;  512		
;  513		tebuflen = 0;
	LD	BC,0
	LD	(_tebuflen),BC
;  514	}
L_92:
	RET	


;**************************** _te_flu ***************************
;Name                         Addr/Register   Size   Type
;_print                              IMPORT  -----   function
;_tebuf                              STATIC   2058   variable
;_tebuflen                           STATIC      3   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


;  515	
;  516	/* Get a character from the console. */
;  517	unsigned char te_gch(void)
;  518	{
_te_gch:
;  519		te_flu();
	CALL	_te_flu
;  520		
;  521		return getch();
	CALL	_getch
;  522	}
	RET	


;**************************** _te_gch ***************************
;Name                         Addr/Register   Size   Type
;_getch                              IMPORT  -----   function
;_te_flu                             IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


;  523	
;  524	/* Writes its argument character to the terminal. */
;  525	void te_chr(char ch)
;  526	{
_te_chr:
	CALL	__frameset0
;  527		tebuf[tebuflen++] = (char) ch;
	LD	BC,_tebuf
	LD	HL,(_tebuflen)
	ADD	HL,BC
	LD	A,(IX+6)
	LD	(HL),A
	LD	BC,(_tebuflen)
	INC	BC
	LD	(_tebuflen),BC
;  528		
;  529		if (tebuflen == TEBUFMAX)
	LD	HL,(_tebuflen)
	OR	A,A
	LD	BC,2048
	SBC	HL,BC
	JR	NZ,L_96
;  530			te_flu();
	CALL	_te_flu
;  531	}
L_96:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _te_chr ***************************
;Name                         Addr/Register   Size   Type
;_te_flu                             IMPORT  -----   function
;_tebuflen                           STATIC      3   variable
;_tebuf                              STATIC   2058   variable
;ch                                    IX+6      1   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  532	
;  533	/* Writes its argument string to the terminal. */
;  534	void te_str(char *s)
;  535	{
_te_str:
	LD	HL,-3
	CALL	__frameset
;  536		while (*s)
	JR	L_98
L_99:
;  537			te_chr((unsigned char)(*s++));
	LD	BC,(IX+6)
	LD	(IX+-3),BC
	LD	BC,(IX+6)
	INC	BC
	LD	(IX+6),BC
	LD	HL,(IX+-3)
	LD	C,(HL)
	LD	B,0
	PUSH	BC
	CALL	_te_chr
	POP	BC
L_98:
	LD	HL,(IX+6)
	LD	A,(HL)
	OR	A,A
	JR	NZ,L_99
;  538	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _te_str ***************************
;Name                         Addr/Register   Size   Type
;_te_chr                             IMPORT  -----   function
;s                                     IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


;  539	
;  540	/* Moves the cursor to the specified row and column on the screen. */
;  541	void te_mov(unsigned char r, unsigned char c)
;  542	{
_te_mov:
	LD	HL,-6
	CALL	__frameset
;  543		as((0 <= r) && (r <= SCNROWS), "te_mov: Bad row.");	//Mod
	LD	A,(IX+6)
	OR	A,A
	JR	C,L_103
	LD	A,50
	CP	A,(IX+6)
	JR	C,L_103
	LD	BC,1
	LD	(IX+-3),BC
	JR	L_104
L_103:
	LD	BC,0
	LD	(IX+-3),BC
L_104:
	LD	BC,L__79
	PUSH	BC
	LD	C,(IX+-3)
	LD	B,0
	PUSH	BC
	CALL	_as
	POP	BC
	POP	BC
;  544		
;  545		as((0 <= c) && (c <= SCNCOLS), "te_mov: Bad col.");	//Mod
	LD	A,(IX+9)
	OR	A,A
	JR	C,L_108
	LD	A,80
	CP	A,(IX+9)
	JR	C,L_108
	LD	BC,1
	LD	(IX+-6),BC
	JR	L_109
L_108:
	LD	BC,0
	LD	(IX+-6),BC
L_109:
	LD	BC,L__82
	PUSH	BC
	LD	C,(IX+-6)
	LD	B,0
	PUSH	BC
	CALL	_as
	POP	BC
	POP	BC
;  546		
;  547		te_flu();
	CALL	_te_flu
;  548		
;  549		gotoxy(c, r);
	LD	C,(IX+6)
	LD	B,0
	PUSH	BC
	LD	C,(IX+9)
	PUSH	BC
	CALL	_gotoxy
	POP	BC
	POP	BC
;  550	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _te_mov ***************************
;Name                         Addr/Register   Size   Type
;_gotoxy                             IMPORT  -----   function
;_te_flu                             IMPORT  -----   function
;_as                                 IMPORT  -----   function
;temp110                               IX-6      3   variable
;temp105                               IX-3      3   variable
;c                                     IX+9      1   parameter
;r                                     IX+6      1   parameter


; Stack Frame Size: 18 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__79:
	DB	"te_mov: Bad row."
	DB	0
L__82:
	DB	"te_mov: Bad col."
	DB	0
	SEGMENT CODE
;  551	
;  552	/* Sets the specified row of the terminal to blanks.   */
;  553	/* Leaves the cursor at the start of the cleared line. */
;  554	void te_cln(unsigned char row)
;  555	{
_te_cln:
	CALL	__frameset0
;  556		te_mov(row, 0);
	LD	BC,0
	PUSH	BC
	LD	C,(IX+6)
	LD	B,0
	PUSH	BC
	CALL	_te_mov
	POP	BC
	POP	BC
;  557		
;  558		clreol();
	CALL	_clreol
;  559	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _te_cln ***************************
;Name                         Addr/Register   Size   Type
;_clreol                             IMPORT  -----   function
;_te_mov                             IMPORT  -----   function
;row                                   IX+6      1   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  560	
;  561	/* Homes the cursor and clears the screen. */
;  562	void te_clr(void)
;  563	{
_te_clr:
	LD	HL,-1
	CALL	__frameset
	LD	(IX+-1),0
;  564		register unsigned char r;
;  565		
;  566		for (r = 0; r < SCNROWS; r++)
	JR	L_116
L_114:
;  567			te_cln(r);
	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	CALL	_te_cln
	POP	BC
	INC	(IX+-1)
L_116:
	LD	A,(IX+-1)
	CP	A,50
	JR	C,L_114
;  568		
;  569		te_mov(0, 0);
	LD	BC,0
	PUSH	BC
	PUSH	BC
	CALL	_te_mov
	POP	BC
	POP	BC
;  570	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _te_clr ***************************
;Name                         Addr/Register   Size   Type
;_te_mov                             IMPORT  -----   function
;_te_cln                             IMPORT  -----   function
;r                                     IX-1      1   variable


; Stack Frame Size: 7 (bytes)
;       Spill Code: 0 (instruction)


;  571	
;  572	/* Initializes the terminal package. */
;  573	void te_ini(void)
;  574	{
_te_ini:
;  575		tebuflen = 0;
	LD	BC,0
	LD	(_tebuflen),BC
;  576	}
	RET	


;**************************** _te_ini ***************************
;Name                         Addr/Register   Size   Type
;_tebuflen                           STATIC      3   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


;  577	
;  578	/* Finalize the terminal package. */
;  579	void te_fin(void)
;  580	{
_te_fin:
;  581		te_flu();
	CALL	_te_flu
;  582	}
	RET	


;**************************** _te_fin ***************************
;Name                         Addr/Register   Size   Type
;_te_flu                             IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


;  583	
;  584	/* Clear the virtual screen. */
;  585	void sc_clr(void)
;  586	{
_sc_clr:
;  587		memset(&scn_virt[0][0], ' ', SCNSIZE);
	LD	BC,4000
	PUSH	BC
	LD	BC,32
	PUSH	BC
	LD	BC,_scn_virt
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  588	}
	RET	


;**************************** _sc_clr ***************************
;Name                         Addr/Register   Size   Type
;_scn_virt                           STATIC   4000   variable
;_memset                             IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


;  589	
;  590	/* Clear the specified row of the virtual screen. */
;  591	void sc_crw(unsigned char row)
;  592	{
_sc_crw:
	LD	HL,-3
	CALL	__frameset
;  593		as((0 <= row) && (row <= SCNROWS), "sc_crw: Bad row number.");
	LD	A,(IX+6)
	OR	A,A
	JR	C,L_124
	LD	A,50
	CP	A,(IX+6)
	JR	C,L_124
	LD	BC,1
	LD	(IX+-3),BC
	JR	L_125
L_124:
	LD	BC,0
	LD	(IX+-3),BC
L_125:
	LD	BC,L__92
	PUSH	BC
	LD	C,(IX+-3)
	LD	B,0
	PUSH	BC
	CALL	_as
	POP	BC
	POP	BC
;  594		
;  595		memset(&scn_virt[row][0], ' ', SCNCOLS);
	LD	BC,80
	PUSH	BC
	LD	BC,32
	PUSH	BC
	LD	A,(IX+6)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_scn_virt
	ADD	HL,BC
	PUSH	HL
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  596	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _sc_crw ***************************
;Name                         Addr/Register   Size   Type
;_scn_virt                           STATIC   4000   variable
;_memset                             IMPORT  -----   function
;_as                                 IMPORT  -----   function
;temp126                               IX-3      3   variable
;row                                   IX+6      1   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__92:
	DB	"sc_crw: Bad row number."
	DB	0
	SEGMENT CODE
;  597	
;  598	/* Places the specified character at the specified row and column on the      */
;  599	/* screen. If the row and column are off screen, it simply does nothing.      */
;  600	void sc_chr(unsigned char row, unsigned char col, unsigned char ch)
;  601	{
_sc_chr:
	CALL	__frameset0
;  602		if (((0 <= row) && (row < SCNROWS)) && ((0 <= col) && (col < SCNCOLS)))
	LD	A,(IX+6)
	OR	A,A
	JR	C,L_132
	LD	A,(IX+6)
	CP	A,50
	JR	NC,L_132
	LD	A,(IX+9)
	OR	A,A
	JR	C,L_132
	LD	A,(IX+9)
	CP	A,80
	JR	NC,L_132
;  603			scn_virt[row - 0][col - 0] = (char) ch;
	LD	A,(IX+6)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,BC
	LD	A,(IX+9)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_scn_virt
	ADD	HL,BC
	LD	BC,HL
	UEXT	HL
	LD	L,A
	LD	A,(IX+12)
	ADD	HL,BC
	LD	(HL),A
;  604	}
L_132:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _sc_chr ***************************
;Name                         Addr/Register   Size   Type
;_scn_virt                           STATIC   4000   variable
;ch                                   IX+12      1   parameter
;col                                   IX+9      1   parameter
;row                                   IX+6      1   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: 0 (instruction)


;  605	
;  606	/* Writes the specified string on the virtual screen at the specified row and column. */
;  607	/* The function ignores any part of the string that falls off the screen.     		  */
;  608	void sc_str(unsigned char row, unsigned char col, char *s)
;  609	{
_sc_str:
	LD	HL,-7
	CALL	__frameset
;  610		unsigned char c = col;
	LD	A,(IX+9)
	LD	(IX+-1),A
;  611		char *t = s;
	LD	BC,(IX+12)
	LD	(IX+-4),BC
;  612		
;  613		while (*t)
	JR	L_135
L_136:
;  614			sc_chr(row, c++, (unsigned char)(*t++));
	LD	A,(IX+-1)
	LD	BC,(IX+-4)
	LD	(IX+-7),BC
	INC	(IX+-1)
	LD	BC,(IX+-4)
	INC	BC
	LD	(IX+-4),BC
	LD	HL,(IX+-7)
	LD	C,(HL)
	LD	B,0
	PUSH	BC
	LD	C,A
	PUSH	BC
	LD	C,(IX+6)
	PUSH	BC
	CALL	_sc_chr
	POP	BC
	POP	BC
	POP	BC
L_135:
	LD	HL,(IX+-4)
	LD	A,(HL)
	OR	A,A
	JR	NZ,L_136
;  615	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _sc_str ***************************
;Name                         Addr/Register   Size   Type
;_sc_chr                             IMPORT  -----   function
;t                                     IX-4      3   variable
;c                                     IX-1      1   variable
;s                                    IX+12      3   parameter
;col                                   IX+9      1   parameter
;row                                   IX+6      1   parameter


; Stack Frame Size: 22 (bytes)
;       Spill Code: 0 (instruction)


;  616	
;  617	/* Updates the physical screen from the virtual screen by:                    */
;  618	/* - Identifying the differences between the physical and virtual screens.    */
;  619	/* - Sending characters to the terminal package to implement the changes.     */
;  620	/* - Setting the physical screen to the virtual screen.                       */
;  621	void sc_upd(void)
;  622	{
_sc_upd:
	LD	HL,-13
	CALL	__frameset
	LD	(IX+-4),0
;  623		register unsigned char r, c;
;  624		
;  625		for (r = 0; r < SCNROWS; r++)
	JR	L_155
L_153:
;  626		{
;  627			if (memcmp(&scn_virt[r - 0][0], &scn_phys[r - 0][0], SCNCOLS) == 0)
	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	(IX+-3),HL
	LD	BC,80
	PUSH	BC
	LD	HL,(IX+-3)
	LD	BC,_scn_phys
	ADD	HL,BC
	PUSH	HL
	LD	HL,(IX+-3)
	LD	BC,_scn_virt
	ADD	HL,BC
	PUSH	HL
	CALL	_memcmp
	POP	BC
	POP	BC
	POP	BC
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	Z,L_154
;  628				continue;
;  629			
;  630			if ((blankrow(&scn_virt[r - 0][0])) && (!blankrow(&scn_phys[r - 0][0])))
	LD	BC,(IX+-3)
	LD	(IX+-13),BC
	LD	BC,(IX+-3)
	LD	(IX+-8),BC
	LD	HL,(IX+-3)
	LD	BC,_scn_virt
	ADD	HL,BC
	PUSH	HL
	CALL	_blankrow
	POP	BC
	OR	A,A
	JR	Z,L_150
	LD	BC,(IX+-3)
	LD	(IX+-13),BC
	LD	BC,(IX+-3)
	LD	(IX+-8),BC
	LD	HL,(IX+-3)
	LD	BC,_scn_phys
	ADD	HL,BC
	PUSH	HL
	CALL	_blankrow
	POP	BC
	OR	A,A
	JR	NZ,L_150
;  631				te_cln(r);
	LD	C,(IX+-4)
	LD	B,0
	PUSH	BC
	CALL	_te_cln
	POP	BC
;  632			else
	JR	L_152
L_150:
;  633			{
;  634				char there = FALSE;
	LD	(IX+-9),0
	LD	(IX+-5),0
;  635				
;  636				for (c = 0; c < SCNCOLS; c++)
	JR	L_148
L_146:
;  637				{
;  638					char ch = scn_virt[r - 0][c - 0];
	LD	BC,(IX+-13)
	LD	(IX+-8),BC
	LD	HL,BC
	LD	BC,_scn_virt
	ADD	HL,BC
	LD	BC,HL
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	LD	(IX+-10),A
;  639					
;  640					if (ch != scn_phys[r - 0][c - 0])
	LD	HL,(IX+-8)
	LD	BC,_scn_phys
	ADD	HL,BC
	LD	BC,HL
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	CP	A,(IX+-10)
	JR	Z,L_145
;  641					{
;  642						if (!there)
	LD	A,(IX+-9)
	OR	A,A
	JR	NZ,L_143
;  643							te_mov(r, c);
	LD	C,(IX+-5)
	LD	B,0
	PUSH	BC
	LD	C,(IX+-4)
	PUSH	BC
	CALL	_te_mov
	POP	BC
	POP	BC
L_143:
;  644						
;  645						te_chr((unsigned char)(ch));
	LD	C,(IX+-10)
	LD	B,0
	PUSH	BC
	CALL	_te_chr
	POP	BC
;  646						
;  647						there = TRUE;
	LD	(IX+-9),1
;  648					}
;  649					else
	JR	L_147
L_145:
;  650						there = FALSE;
	LD	(IX+-9),0
;  651				}
L_147:
	INC	(IX+-5)
L_148:
	LD	A,(IX+-5)
	CP	A,80
	JR	C,L_146
;  652			}
L_152:
;  653			
;  654			memmove(&scn_phys[r - 0][0], &scn_virt[r - 0][0], SCNCOLS);
	LD	BC,(IX+-8)
	LD	HL,BC
	LD	DE,80
	PUSH	DE
	LD	DE,_scn_virt
	ADD	HL,DE
	PUSH	HL
	LD	HL,BC
	LD	BC,_scn_phys
	ADD	HL,BC
	PUSH	HL
	CALL	_memmove
	POP	BC
	POP	BC
	POP	BC
;  655		}	
L_154:
	INC	(IX+-4)
L_155:
	LD	A,(IX+-4)
	CP	A,50
	JR	C,L_153
;  656		
;  657		te_flu();	
	CALL	_te_flu
;  658	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _sc_upd ***************************
;Name                         Addr/Register   Size   Type
;_te_flu                             IMPORT  -----   function
;_memmove                            IMPORT  -----   function
;_te_chr                             IMPORT  -----   function
;_te_mov                             IMPORT  -----   function
;_te_cln                             IMPORT  -----   function
;_blankrow                           IMPORT  -----   function
;_scn_virt                           STATIC   4000   variable
;_scn_phys                           STATIC   4000   variable
;_memcmp                             IMPORT  -----   function
;G_3                                  IX-13      3   variable
;ch                                   IX-10      1   variable
;there                                 IX-9      1   variable
;G_4                                   IX-8      3   variable
;c                                     IX-5      1   variable
;r                                     IX-4      1   variable
;G_1                                   IX-3      3   variable


; Stack Frame Size: 19 (bytes)
;       Spill Code: 0 (instruction)


;  659	
;  660	/* Forced update. Forces the terminals screen to be redrawn from scratch from */
;  661	/* the virtual screen.                                                        */
;  662	void sc_fup(void)
;  663	{
_sc_fup:
;  664		memset(&scn_phys[0][0], 0, SCNSIZE);
	LD	BC,4000
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_scn_phys
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  665		
;  666		sc_upd();
	CALL	_sc_upd
;  667	}
	RET	


;**************************** _sc_fup ***************************
;Name                         Addr/Register   Size   Type
;_sc_upd                             IMPORT  -----   function
;_scn_phys                           STATIC   4000   variable
;_memset                             IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


;  668	
;  669	/* Initializes the screen package, clearing the screen. */
;  670	void sc_ini(void)
;  671	{
_sc_ini:
;  672		sc_clr();
	CALL	_sc_clr
;  673		
;  674		sc_fup();
	CALL	_sc_fup
;  675	}
	RET	


;**************************** _sc_ini ***************************
;Name                         Addr/Register   Size   Type
;_sc_fup                             IMPORT  -----   function
;_sc_clr                             IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


;  676	
;  677	/* Finalizes the screen package, clearing the screen. */
;  678	void sc_fin(void)
;  679	{
_sc_fin:
;  680		sc_clr();
	CALL	_sc_clr
;  681		
;  682		sc_fup();
	CALL	_sc_fup
;  683	}
	RET	


;**************************** _sc_fin ***************************
;Name                         Addr/Register   Size   Type
;_sc_fup                             IMPORT  -----   function
;_sc_clr                             IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


;  684	
;  685	/* Initialize the text data structure to the empty list. */
;  686	void tx_ini(void)
;  687	{
_tx_ini:
;  688		p_root = &root;
	LD	BC,_root
	LD	(_p_root),BC
;  689		p_root->p_next = p_root;
	LD	(_root+3),BC
;  690		p_root->p_prev = p_root;
	LD	(_root),BC
;  691		p_root->p_data = NULL;
	LD	BC,0
	LD	(_root+6),BC
;  692		
;  693		numlines = 0;
	LD	(_numlines),BC
;  694	}
	RET	


;**************************** _tx_ini ***************************
;Name                         Addr/Register   Size   Type
;_numlines                           STATIC      3   variable
;_p_root                             STATIC      3   variable
;_root                               STATIC      9   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


;  695	
;  696	/* Sets the specified line to the specified string value. */
;  697	/* Deletes trailing spaces from the argument string first. */
;  698	void tx_set(p_line_t p_line, char *s)
;  699	{
_tx_set:
	LD	HL,-3
	CALL	__frameset
;  700		size_t len;
;  701		
;  702		zap_trail(s);
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_zap_trail
	POP	BC
;  703		
;  704		len = strlen(s);
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_strlen
	POP	BC
	LD	(IX+-3),HL
;  705		
;  706		as(len <= MAXLNLEN, "tx_set: Line too long.");	
	LD	BC,L__113
	PUSH	BC
	LD	BC,(IX+-3)
	LD	HL,80
	OR	A,A
	SBC	HL,BC
	JR	C,L__115
	LD	A,1
	JR	L__116
L__115:
	XOR	A,A
L__116:
	LD	C,A
	LD	B,0
	PUSH	BC
	CALL	_as
	POP	BC
	POP	BC
;  707		as(p_line != p_root, "tx_set: Attempt to set the root line.");
	LD	BC,L__117
	PUSH	BC
	LD	BC,(IX+6)
	LD	HL,(_p_root)
	OR	A,A
	SBC	HL,BC
	JR	Z,L__119
	LD	A,1
	JR	L__120
L__119:
	XOR	A,A
L__120:
	LD	C,A
	LD	B,0
	PUSH	BC
	CALL	_as
	POP	BC
	POP	BC
;  708		as(p_line->p_data != NULL, "tx_set: p_data=NULL.");
	LD	BC,L__121
	PUSH	BC
	LD	IY,(IX+6)
	LD	HL,(IY+6)
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	Z,L__123
	LD	A,1
	JR	L__124
L__123:
	XOR	A,A
L__124:
	LD	C,A
	LD	B,0
	PUSH	BC
	CALL	_as
	POP	BC
	POP	BC
;  709		
;  710		free(p_line->p_data);
	LD	IY,(IX+6)
	LD	BC,(IY+6)
	PUSH	BC
	CALL	_free
	POP	BC
;  711		
;  712		p_line->p_data = mymalloc(len + 1);
	LD	BC,(IX+-3)
	INC	BC
	PUSH	BC
	CALL	_mymalloc
	POP	BC
	LD	IY,(IX+6)
	LD	(IY+6),HL
;  713		
;  714		strcpy(p_line->p_data, s);
	LD	BC,(IX+9)
	PUSH	BC
	LD	BC,(IY+6)
	PUSH	BC
	CALL	_strcpy
	POP	BC
	POP	BC
;  715	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _tx_set ***************************
;Name                         Addr/Register   Size   Type
;_strcpy                             IMPORT  -----   function
;_mymalloc                           IMPORT  -----   function
;_free                               IMPORT  -----   function
;_p_root                             STATIC      3   variable
;_as                                 IMPORT  -----   function
;_strlen                             IMPORT  -----   function
;_zap_trail                          IMPORT  -----   function
;len                                   IX-3      3   variable
;s                                     IX+9      3   parameter
;p_line                                IX+6      3   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__113:
	DB	"tx_set: Line too long."
	DB	0
L__117:
	DB	"tx_set: Attempt to set the root line."
	DB	0
L__121:
	DB	"tx_set: p_data=NULL."
	DB	0
	SEGMENT CODE
;  716	
;  717	/* Insert a line containing the specified string */
;  718	/* just before the specified line.               */
;  719	void tx_ins(p_line_t p_line, char *s)
;  720	{
_tx_ins:
	LD	HL,-3
	CALL	__frameset
;  721		p_line_t p_new = mymalloc(sizeof(line_t));
	LD	BC,9
	PUSH	BC
	CALL	_mymalloc
	POP	BC
	LD	(IX+-3),HL
;  722		
;  723		p_new->p_prev = p_line->p_prev;
	LD	IY,(IX+6)
	LD	BC,(IY+0)
	LD	IY,(IX+-3)
	LD	(IY+0),BC
;  724		p_new->p_next = p_line;
	LD	BC,(IX+6)
	LD	(IY+3),BC
;  725		
;  726		p_line->p_prev = p_new;
	LD	BC,(IX+-3)
	LD	IY,(IX+6)
	LD	(IY+0),BC
;  727		p_new->p_prev->p_next = p_new;
	LD	IY,(IX+-3)
	LD	IY,(IY+0)
	LD	BC,(IX+-3)
;  728		
;  729		p_new->p_data = mymalloc(0);
	LD	DE,0
	PUSH	DE
	LD	(IY+3),BC
	CALL	_mymalloc
	POP	BC
	LD	IY,(IX+-3)
	LD	(IY+6),HL
;  730		
;  731		tx_set(p_new, s);
	LD	BC,(IX+9)
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_tx_set
	POP	BC
	POP	BC
;  732		
;  733		numlines++;
	LD	BC,(_numlines)
	INC	BC
	LD	(_numlines),BC
;  734	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _tx_ins ***************************
;Name                         Addr/Register   Size   Type
;_numlines                           STATIC      3   variable
;_tx_set                             IMPORT  -----   function
;_mymalloc                           IMPORT  -----   function
;p_new                                 IX-3      3   variable
;s                                     IX+9      3   parameter
;p_line                                IX+6      3   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: 0 (instruction)


;  735	
;  736	/* Deletes the specified line. */
;  737	void tx_del(p_line_t p_line)
;  738	{
_tx_del:
	LD	HL,-3
	CALL	__frameset
;  739		as(p_line != NULL, "tx_del: NULL.");
	LD	BC,L__127
	PUSH	BC
	LD	HL,(IX+6)
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	Z,L__129
	LD	A,1
	JR	L__130
L__129:
	XOR	A,A
L__130:
	LD	C,A
	LD	B,0
	PUSH	BC
	CALL	_as
	POP	BC
	POP	BC
;  740		as(p_line != p_root, "tx_del: Attempt to delete the root line.");
	LD	BC,L__131
	PUSH	BC
	LD	BC,(IX+6)
	LD	HL,(_p_root)
	OR	A,A
	SBC	HL,BC
	JR	Z,L__133
	LD	A,1
	JR	L__134
L__133:
	XOR	A,A
L__134:
	LD	C,A
	LD	B,0
	PUSH	BC
	CALL	_as
	POP	BC
	POP	BC
;  741		
;  742		p_line->p_prev->p_next = p_line->p_next;
	LD	IY,(IX+6)
	LD	BC,(IY+0)
	LD	(IX+-3),BC
	LD	BC,(IY+3)
	LD	IY,(IX+-3)
	LD	(IY+3),BC
;  743		p_line->p_next->p_prev = p_line->p_prev;
	LD	IY,(IX+6)
	LD	IY,(IY+3)
	LD	BC,(IX+-3)
	LD	(IY+0),BC
;  744		
;  745		free(p_line->p_data);
	LD	IY,(IX+6)
	LD	BC,(IY+6)
	PUSH	BC
	CALL	_free
	POP	BC
;  746		free(p_line);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_free
	POP	BC
;  747		
;  748		numlines--;
	LD	BC,(_numlines)
	DEC	BC
	LD	(_numlines),BC
;  749	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _tx_del ***************************
;Name                         Addr/Register   Size   Type
;_numlines                           STATIC      3   variable
;_free                               IMPORT  -----   function
;_p_root                             STATIC      3   variable
;_as                                 IMPORT  -----   function
;p_line                                IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__127:
	DB	"tx_del: NULL."
	DB	0
L__131:
	DB	"tx_del: Attempt to delete the root line."
	DB	0
	SEGMENT CODE
;  750	
;  751	/* Writes the contents of the line to the global line buffer as a blank       */
;  752	/* padded array of MAXLNLEN characters.                                       */
;  753	void tx_get(p_line_t p_line)
;  754	{
_tx_get:
	LD	HL,-3
	CALL	__frameset
;  755		size_t len = strlen(p_line->p_data);
	LD	IY,(IX+6)
	LD	BC,(IY+6)
	PUSH	BC
	CALL	_strlen
	POP	BC
	LD	(IX+-3),HL
;  756		
;  757		memset((void *)linbuf, ' ', MAXLNLEN);
	LD	BC,80
	PUSH	BC
	LD	BC,32
	PUSH	BC
	LD	BC,_linbuf
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  758		
;  759		memmove((void *)linbuf, p_line->p_data, len);
	LD	BC,(IX+-3)
	PUSH	BC
	LD	IY,(IX+6)
	LD	BC,(IY+6)
	PUSH	BC
	LD	BC,_linbuf
	PUSH	BC
	CALL	_memmove
	POP	BC
	POP	BC
	POP	BC
;  760	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _tx_get ***************************
;Name                         Addr/Register   Size   Type
;_memmove                            IMPORT  -----   function
;_linbuf                             STATIC     90   variable
;_memset                             IMPORT  -----   function
;_strlen                             IMPORT  -----   function
;len                                   IX-3      3   variable
;p_line                                IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


;  761	
;  762	/* Sets the value of the specified line to the value of the global linebuffer.*/
;  763	void tx_put(p_line_t p_line)
;  764	{
_tx_put:
	CALL	__frameset0
;  765		linbuf[MAXLNLEN] = EOS;
	LD	HL,_linbuf+80
;  766		
;  767		tx_set(p_line, linbuf);
	LD	BC,_linbuf
	PUSH	BC
	LD	(HL),0
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_tx_set
	POP	BC
	POP	BC
;  768	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _tx_put ***************************
;Name                         Addr/Register   Size   Type
;_tx_set                             IMPORT  -----   function
;_linbuf                             STATIC     90   variable
;p_line                                IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  769	
;  770	/* Redraw the screen. */
;  771	void do_red(void)
;  772	{
_do_red:
;  773		sc_fup();
	CALL	_sc_fup
;  774	}
	RET	


;**************************** _do_red ***************************
;Name                         Addr/Register   Size   Type
;_sc_fup                             IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


;  775	
;  776	/* Cursor up. */
;  777	void do_cup(void)
;  778	{
_do_cup:
	LD	HL,-1
	CALL	__frameset
;  779		char ch;
;  780		
;  781		if (cur_line == 1)
	LD	BC,1
	LD	HL,(_cur_line)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_172
;  782		{
;  783			Show_Cursor();
	CALL	_Show_Cursor
;  784			
;  785			return;
	JR	L_176
;  786		}
L_172:
;  787		
;  788		cur_line--;
	LD	BC,(_cur_line)
	DEC	BC
	LD	(_cur_line),BC
;  789		
;  790		p_curr = p_curr->p_prev;
	LD	IY,(_p_curr)
	LD	BC,(IY+0)
	LD	(_p_curr),BC
;  791		
;  792		if (cur_row == 0)
	LD	HL,(_cur_row)
	OR	A,A
	LD	BC,0
	SBC	HL,BC
	JR	NZ,L_175
;  793			paintall();
	CALL	_paintall
;  794		else
	JR	L_176
L_175:
;  795		{
;  796			ch = scn_phys[cur_row][cur_col];
	LD	HL,(_cur_row)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,(_cur_row)
	ADD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_scn_phys
	ADD	HL,BC
	LD	BC,(_cur_col)
	ADD	HL,BC
	LD	A,(HL)
	LD	(IX+-1),A
;  797			
;  798			cur_row--;
	LD	BC,(_cur_row)
	DEC	BC
	LD	(_cur_row),BC
;  799			
;  800			plot_char(cur_col, cur_row + 1, ch);
	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	LD	A,(_cur_row)
	INC	A
	LD	C,A
	PUSH	BC
	LD	A,(_cur_col)
	LD	C,A
	PUSH	BC
	CALL	_plot_char
	POP	BC
	POP	BC
	POP	BC
;  801		}
;  802	}
L_176:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _do_cup ***************************
;Name                         Addr/Register   Size   Type
;_plot_char                          IMPORT  -----   function
;_cur_col                            STATIC      3   variable
;_scn_phys                           STATIC   4000   variable
;_paintall                           IMPORT  -----   function
;_cur_row                            STATIC      3   variable
;_p_curr                             STATIC      3   variable
;_Show_Cursor                        IMPORT  -----   function
;_cur_line                           STATIC      3   variable
;ch                                    IX-1      1   variable


; Stack Frame Size: 7 (bytes)
;       Spill Code: 0 (instruction)


;  803	
;  804	/* Cursor down. */
;  805	void do_cdw(void)
;  806	{
_do_cdw:
	LD	HL,-4
	CALL	__frameset
;  807		char ch;
;  808		
;  809		if (p_curr->p_next == p_root)
	LD	IY,(_p_curr)
	LD	BC,(IY+3)
	LD	(IX+-4),BC
	LD	HL,(_p_root)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_178
;  810		{
;  811			Show_Cursor();
	CALL	_Show_Cursor
;  812			
;  813			return;
	JR	L_183
;  814		}
L_178:
;  815		
;  816		p_curr = p_curr->p_next;
	LD	BC,(IX+-4)
	LD	(_p_curr),BC
;  817		
;  818		cur_line++;
	LD	BC,(_cur_line)
	INC	BC
	LD	(_cur_line),BC
;  819		
;  820		if (cur_row == SCNROWS - 1)
	LD	HL,(_cur_row)
	OR	A,A
	LD	BC,49
	SBC	HL,BC
	JR	NZ,L_182
;  821			paintall();	
	CALL	_paintall
;  822		else
	JR	L_183
L_182:
;  823		{
;  824			ch = scn_phys[cur_row][cur_col];
	LD	HL,(_cur_row)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,(_cur_row)
	ADD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_scn_phys
	ADD	HL,BC
	LD	BC,(_cur_col)
	ADD	HL,BC
	LD	A,(HL)
	LD	(IX+-1),A
;  825			
;  826			cur_row++;
	LD	BC,(_cur_row)
	INC	BC
	LD	(_cur_row),BC
;  827			
;  828			plot_char(cur_col, cur_row - 1, ch);		
	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	LD	A,(_cur_row)
	DEC	A
	LD	C,A
	PUSH	BC
	LD	A,(_cur_col)
	LD	C,A
	PUSH	BC
	CALL	_plot_char
	POP	BC
	POP	BC
	POP	BC
;  829		}
;  830	}
L_183:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _do_cdw ***************************
;Name                         Addr/Register   Size   Type
;_plot_char                          IMPORT  -----   function
;_cur_col                            STATIC      3   variable
;_scn_phys                           STATIC   4000   variable
;_paintall                           IMPORT  -----   function
;_cur_row                            STATIC      3   variable
;_cur_line                           STATIC      3   variable
;_Show_Cursor                        IMPORT  -----   function
;_p_root                             STATIC      3   variable
;_p_curr                             STATIC      3   variable
;G_5                                   IX-4      3   variable
;ch                                    IX-1      1   variable


; Stack Frame Size: 10 (bytes)
;       Spill Code: 0 (instruction)


;  831	
;  832	/* Cursor left. */
;  833	void do_clf(void)
;  834	{
_do_clf:
	LD	HL,-1
	CALL	__frameset
;  835		char ch;
;  836		
;  837		if (cur_char == 1)
	LD	BC,1
	LD	HL,(_cur_char)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_186
;  838		{
;  839			Show_Cursor();
	CALL	_Show_Cursor
;  840			
;  841			return;
	JR	L_190
;  842		}
L_186:
;  843		
;  844		cur_char--;
	LD	BC,(_cur_char)
	DEC	BC
	LD	(_cur_char),BC
;  845		
;  846		if (cur_col == 0)
	LD	HL,(_cur_col)
	OR	A,A
	LD	BC,0
	SBC	HL,BC
	JR	NZ,L_189
;  847			paintall();
	CALL	_paintall
;  848		else
	JR	L_190
L_189:
;  849		{
;  850			ch = scn_phys[cur_row][cur_col];
	LD	HL,(_cur_row)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,(_cur_row)
	ADD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_scn_phys
	ADD	HL,BC
	LD	BC,(_cur_col)
	ADD	HL,BC
	LD	A,(HL)
	LD	(IX+-1),A
;  851			
;  852			cur_col--;
	LD	BC,(_cur_col)
	DEC	BC
	LD	(_cur_col),BC
;  853			
;  854			plot_char(cur_col + 1, cur_row, ch);
	LD	C,(IX+-1)
	LD	A,(_cur_row)
	LD	B,0
	PUSH	BC
	LD	C,A
	PUSH	BC
	LD	A,(_cur_col)
	INC	A
	LD	C,A
	PUSH	BC
	CALL	_plot_char
	POP	BC
	POP	BC
	POP	BC
;  855		}
;  856	}
L_190:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _do_clf ***************************
;Name                         Addr/Register   Size   Type
;_plot_char                          IMPORT  -----   function
;_cur_row                            STATIC      3   variable
;_scn_phys                           STATIC   4000   variable
;_paintall                           IMPORT  -----   function
;_cur_col                            STATIC      3   variable
;_Show_Cursor                        IMPORT  -----   function
;_cur_char                           STATIC      3   variable
;ch                                    IX-1      1   variable


; Stack Frame Size: 7 (bytes)
;       Spill Code: 0 (instruction)


;  857	
;  858	/* Cursor right. */
;  859	void do_crt(void)
;  860	{
_do_crt:
	LD	HL,-1
	CALL	__frameset
;  861		char ch;
;  862		
;  863		if (cur_char == MAXLNLEN)
	LD	BC,80
	LD	HL,(_cur_char)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_193
;  864		{
;  865			Show_Cursor();
	CALL	_Show_Cursor
;  866			
;  867			return;
	JR	L_197
;  868		}
L_193:
;  869		
;  870		cur_char++;
	LD	BC,(_cur_char)
	INC	BC
	LD	(_cur_char),BC
;  871		
;  872		if (cur_col == SCNCOLS - 1)
	LD	HL,(_cur_col)
	OR	A,A
	LD	BC,79
	SBC	HL,BC
	JR	NZ,L_196
;  873			paintall();
	CALL	_paintall
;  874		else
	JR	L_197
L_196:
;  875		{
;  876			ch = scn_phys[cur_row][cur_col];
	LD	HL,(_cur_row)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,(_cur_row)
	ADD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_scn_phys
	ADD	HL,BC
	LD	BC,(_cur_col)
	ADD	HL,BC
	LD	A,(HL)
	LD	(IX+-1),A
;  877			
;  878			cur_col++;
	LD	BC,(_cur_col)
	INC	BC
	LD	(_cur_col),BC
;  879			
;  880			plot_char(cur_col - 1, cur_row, ch);
	LD	C,(IX+-1)
	LD	A,(_cur_row)
	LD	B,0
	PUSH	BC
	LD	C,A
	PUSH	BC
	LD	A,(_cur_col)
	DEC	A
	LD	C,A
	PUSH	BC
	CALL	_plot_char
	POP	BC
	POP	BC
	POP	BC
;  881		}
;  882	}
L_197:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _do_crt ***************************
;Name                         Addr/Register   Size   Type
;_plot_char                          IMPORT  -----   function
;_cur_row                            STATIC      3   variable
;_scn_phys                           STATIC   4000   variable
;_paintall                           IMPORT  -----   function
;_cur_col                            STATIC      3   variable
;_Show_Cursor                        IMPORT  -----   function
;_cur_char                           STATIC      3   variable
;ch                                    IX-1      1   variable


; Stack Frame Size: 7 (bytes)
;       Spill Code: 0 (instruction)


;  883	
;  884	/* Page down. */
;  885	void do_pdw(void)
;  886	{
_do_pdw:
	LD	HL,-3
	CALL	__frameset
;  887		register char i;
;  888		char ch, oldr = cur_row;
	LD	A,(_cur_row)
	LD	(IX+-2),A
	LD	(IX+-1),0
;  889		
;  890		for (i = 0; i < SCNROWS; i++)
	JR	L_205
L_203:
;  891		{
;  892			if (cur_line == numlines + 1)
	LD	HL,(_numlines)
	INC	HL
	OR	A,A
	LD	BC,(_cur_line)
	SBC	HL,BC
	JR	Z,L_207
;  893				break;
;  894			
;  895			p_curr = p_curr->p_next;
	LD	IY,(_p_curr)
	LD	BC,(IY+3)
	LD	(_p_curr),BC
;  896			
;  897			cur_line++;
	LD	BC,(_cur_line)
	INC	BC
	LD	(_cur_line),BC
;  898			cur_row++;
	LD	BC,(_cur_row)
	INC	BC
	LD	(_cur_row),BC
	INC	(IX+-1)
;  899		}
L_205:
	LD	A,(IX+-1)
	CP	A,50
	JP	M,L_203
L_207:
;  900		
;  901		if (cur_row > SCNROWS - 1)
	LD	BC,(_cur_row)
	LD	HL,49
	OR	A,A
	SBC	HL,BC
	JP	P,L__154
	JP	PE,L_208
	JR	L__155
L__154:
	JP	PO,L_208
L__155:
;  902			cur_row = SCNROWS - 1;
	LD	BC,49
	LD	(_cur_row),BC
L_208:
;  903		
;  904		paintall();
	CALL	_paintall
;  905		
;  906		ch = scn_phys[oldr][cur_col];
	LD	A,(IX+-2)
	SEXT	HL
	LD	L,(IX+-2)
	LD	BC,HL
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_scn_phys
	ADD	HL,BC
	LD	BC,(_cur_col)
	ADD	HL,BC
	LD	A,(HL)
	LD	(IX+-3),A
;  907		
;  908		plot_char(cur_col, oldr, ch);
	LD	C,(IX+-3)
	LD	B,0
	PUSH	BC
	LD	C,(IX+-2)
	LD	A,(_cur_col)
	PUSH	BC
	LD	C,A
	PUSH	BC
	CALL	_plot_char
	POP	BC
	POP	BC
	POP	BC
;  909		
;  910		Show_Cursor();
	CALL	_Show_Cursor
;  911	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _do_pdw ***************************
;Name                         Addr/Register   Size   Type
;_Show_Cursor                        IMPORT  -----   function
;_plot_char                          IMPORT  -----   function
;_cur_col                            STATIC      3   variable
;_scn_phys                           STATIC   4000   variable
;_paintall                           IMPORT  -----   function
;_p_curr                             STATIC      3   variable
;_cur_line                           STATIC      3   variable
;_numlines                           STATIC      3   variable
;_cur_row                            STATIC      3   variable
;ch                                    IX-3      1   variable
;oldr                                  IX-2      1   variable
;i                                     IX-1      1   variable


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  912	
;  913	/* Page up. */
;  914	void do_pup(void)
;  915	{
_do_pup:
	LD	HL,-3
	CALL	__frameset
;  916		register char i;
;  917		char ch, oldr = cur_row;
	LD	A,(_cur_row)
	LD	(IX+-2),A
	LD	(IX+-1),0
;  918		
;  919		for (i = 0; i < SCNROWS; i++)
	JR	L_217
L_215:
;  920		{
;  921			if (cur_line == 1)
	LD	BC,1
	LD	HL,(_cur_line)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_219
;  922				break;
;  923			
;  924			p_curr = p_curr->p_prev;
	LD	IY,(_p_curr)
	LD	BC,(IY+0)
	LD	(_p_curr),BC
;  925			
;  926			cur_line--;
	LD	BC,(_cur_line)
	DEC	BC
	LD	(_cur_line),BC
;  927			cur_row--;
	LD	BC,(_cur_row)
	DEC	BC
	LD	(_cur_row),BC
	INC	(IX+-1)
;  928		}
L_217:
	LD	A,(IX+-1)
	CP	A,50
	JP	M,L__160
	JP	PE,L_215
	JR	L__161
L__160:
	JP	PO,L_215
L__161:
L_219:
;  929		
;  930		if (cur_row < 0)
	LD	BC,0
	LD	HL,(_cur_row)
	OR	A,A
	SBC	HL,BC
	JP	P,L__162
	JP	PE,L_220
	JR	L__163
L__162:
	JP	PO,L_220
L__163:
;  931			cur_row = 0;	
	LD	BC,0
	LD	(_cur_row),BC
L_220:
;  932		
;  933		paintall();
	CALL	_paintall
;  934		
;  935		ch = scn_phys[oldr][cur_col];
	LD	A,(IX+-2)
	SEXT	HL
	LD	L,(IX+-2)
	LD	BC,HL
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_scn_phys
	ADD	HL,BC
	LD	BC,(_cur_col)
	ADD	HL,BC
	LD	A,(HL)
	LD	(IX+-3),A
;  936		
;  937		plot_char(cur_col, oldr, ch);
	LD	C,(IX+-3)
	LD	B,0
	PUSH	BC
	LD	C,(IX+-2)
	LD	A,(_cur_col)
	PUSH	BC
	LD	C,A
	PUSH	BC
	CALL	_plot_char
	POP	BC
	POP	BC
	POP	BC
;  938		
;  939		Show_Cursor();
	CALL	_Show_Cursor
;  940	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _do_pup ***************************
;Name                         Addr/Register   Size   Type
;_Show_Cursor                        IMPORT  -----   function
;_plot_char                          IMPORT  -----   function
;_cur_col                            STATIC      3   variable
;_scn_phys                           STATIC   4000   variable
;_paintall                           IMPORT  -----   function
;_p_curr                             STATIC      3   variable
;_cur_line                           STATIC      3   variable
;_cur_row                            STATIC      3   variable
;ch                                    IX-3      1   variable
;oldr                                  IX-2      1   variable
;i                                     IX-1      1   variable


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  941	
;  942	/* Return. */
;  943	void do_ret(void)
;  944	{
_do_ret:
	LD	HL,-4
	CALL	__frameset
;  945		char len = strlen(p_curr->p_data);
	LD	IY,(_p_curr)
	LD	BC,(IY+6)
	PUSH	BC
	CALL	_strlen
	POP	BC
	LD	(IX+-4),L
;  946		char ch, oldr = cur_row, oldc = cur_col;
	LD	A,(_cur_row)
	LD	(IX+-1),A
	LD	A,(_cur_col)
	LD	(IX+-2),A
;  947		
;  948		gotoxy(len, cur_row);
	LD	A,(_cur_row)
	LD	C,A
	LD	B,0
	PUSH	BC
	LD	C,(IX+-4)
	PUSH	BC
	CALL	_gotoxy
	POP	BC
	POP	BC
;  949		
;  950		clreol();
	CALL	_clreol
;  951		
;  952		ch = scn_phys[oldr][oldc];
	LD	A,(IX+-1)
	SEXT	HL
	LD	L,(IX+-1)
	LD	BC,HL
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	A,(IX+-2)
	LD	BC,_scn_phys
	ADD	HL,BC
	LD	BC,HL
	SEXT	HL
	LD	L,(IX+-2)
	ADD	HL,BC
	LD	A,(HL)
	LD	(IX+-3),A
;  953		
;  954		plot_char(oldc, oldr, ch);
	LD	C,(IX+-3)
	LD	B,0
	PUSH	BC
	LD	C,(IX+-1)
	PUSH	BC
	LD	C,(IX+-2)
	PUSH	BC
	CALL	_plot_char
	POP	BC
	POP	BC
	POP	BC
;  955		
;  956		cur_char = 1;
	LD	BC,1
	LD	(_cur_char),BC
;  957		cur_col  = 0;
	LD	BC,0
	LD	(_cur_col),BC
;  958		
;  959		ch = scn_phys[oldr][oldc];
	LD	A,(IX+-1)
	SEXT	HL
	LD	L,(IX+-1)
	LD	BC,HL
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	A,(IX+-2)
	LD	BC,_scn_phys
	ADD	HL,BC
	LD	BC,HL
	SEXT	HL
	LD	L,(IX+-2)
	ADD	HL,BC
	LD	A,(HL)
	LD	(IX+-3),A
;  960		
;  961		plot_char(oldc, oldr, ch);
	LD	C,(IX+-3)
	LD	B,0
	PUSH	BC
	LD	C,(IX+-1)
	PUSH	BC
	LD	C,(IX+-2)
	PUSH	BC
	CALL	_plot_char
	POP	BC
	POP	BC
	POP	BC
;  962		
;  963		do_cdw();
	CALL	_do_cdw
;  964	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _do_ret ***************************
;Name                         Addr/Register   Size   Type
;_do_cdw                             IMPORT  -----   function
;_cur_char                           STATIC      3   variable
;_plot_char                          IMPORT  -----   function
;_scn_phys                           STATIC   4000   variable
;_clreol                             IMPORT  -----   function
;_gotoxy                             IMPORT  -----   function
;_cur_col                            STATIC      3   variable
;_cur_row                            STATIC      3   variable
;_p_curr                             STATIC      3   variable
;_strlen                             IMPORT  -----   function
;len                                   IX-4      1   variable
;ch                                    IX-3      1   variable
;oldc                                  IX-2      1   variable
;oldr                                  IX-1      1   variable


; Stack Frame Size: 10 (bytes)
;       Spill Code: 0 (instruction)


;  965	
;  966	/* Enhanced Return. Break a line into two lines */
;  967	void do_enhanced_ret(void)
;  968	{
_do_enhanced_ret:
	LD	HL,-161
	CALL	__frameset
;  969		char len = strlen(p_curr->p_data);
	LD	IY,(_p_curr)
	LD	BC,(IY+6)
	PUSH	BC
	CALL	_strlen
	POP	BC
	LD	(IX+-1),L
;  970		char app[MAXLNLEN], app2[MAXLNLEN];
;  971		
;  972		if (cur_col < len)
	LD	A,(IX+-1)
	SEXT	HL
	LD	L,(IX+-1)
	LD	BC,HL
	LD	HL,(_cur_col)
	OR	A,A
	SBC	HL,BC
	JP	P,L__167
	JP	PE,L_224
	JR	L__168
L__167:
	JP	PO,L_224
L__168:
;  973		{
;  974			memset(app, 0, MAXLNLEN);
	LD	BC,80
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PEA	IX+-81
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  975			memset(app2, 0, MAXLNLEN);
	LD	BC,80
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	HL,IX
	LD	BC,-161
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  976			
;  977			memmove(app, p_curr->p_data + cur_col, len - cur_col);
	LD	A,(IX+-1)
	SEXT	HL
	LD	L,(IX+-1)
	OR	A,A
	LD	BC,(_cur_col)
	LD	IY,(_p_curr)
	LD	DE,(_cur_col)
	SBC	HL,BC
	PUSH	HL
	LD	HL,(IY+6)
	ADD	HL,DE
	PUSH	HL
	PEA	IX+-81
	CALL	_memmove
	POP	BC
	POP	BC
	POP	BC
;  978			
;  979			memmove(app2, p_curr->p_data, cur_col);
	LD	BC,(_cur_col)
	PUSH	BC
	LD	IY,(_p_curr)
	LD	BC,(IY+6)
	PUSH	BC
	LD	HL,IX
	LD	BC,-161
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_memmove
	POP	BC
	POP	BC
	POP	BC
;  980			
;  981			do_iln();
	CALL	_do_iln
;  982			
;  983			tx_set(p_curr, app);
	PEA	IX+-81
	LD	BC,(_p_curr)
	PUSH	BC
	CALL	_tx_set
	POP	BC
	POP	BC
;  984			
;  985			tx_set(p_curr->p_prev, app2);
	LD	HL,IX
	LD	BC,-161
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	LD	IY,(_p_curr)
	LD	BC,(IY+0)
	PUSH	BC
	CALL	_tx_set
	POP	BC
	POP	BC
;  986			
;  987			paintall();
	CALL	_paintall
;  988			
;  989			do_cup();
	CALL	_do_cup
;  990		}
L_224:
;  991		
;  992		do_ret();
	CALL	_do_ret
;  993	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _do_enhanced_ret ***************************
;Name                         Addr/Register   Size   Type
;_do_ret                             IMPORT  -----   function
;_do_cup                             IMPORT  -----   function
;_paintall                           IMPORT  -----   function
;_tx_set                             IMPORT  -----   function
;_do_iln                             IMPORT  -----   function
;_memmove                            IMPORT  -----   function
;_memset                             IMPORT  -----   function
;_cur_col                            STATIC      3   variable
;_p_curr                             STATIC      3   variable
;_strlen                             IMPORT  -----   function
;app2                                IX-161     80   variable
;app                                  IX-81     80   variable
;len                                   IX-1      1   variable


; Stack Frame Size: 167 (bytes)
;       Spill Code: 0 (instruction)


;  994	
;  995	/* Tab. */
;  996	void do_tab(void)
;  997	{
_do_tab:
	LD	HL,-3
	CALL	__frameset
;  998		int x = cur_char;
	LD	BC,(_cur_char)
	LD	(IX+-3),BC
;  999		
; 1000		do
L_227:
; 1001		{
; 1002			do_crt();
	CALL	_do_crt
; 1003			x++;
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
; 1004		} while (((x - 1) % 8) != 0);
	LD	HL,BC
	DEC	HL
	LD	BC,8
	CALL	__irems
	OR	A,A
	LD	BC,0
	SBC	HL,BC
	JR	NZ,L_227
; 1005	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _do_tab ***************************
;Name                         Addr/Register   Size   Type
;_do_crt                             IMPORT  -----   function
;_cur_char                           STATIC      3   variable
;x                                     IX-3      3   variable


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


; 1006	
; 1007	/* Jump to top of document. */
; 1008	void do_top(void)
; 1009	{
_do_top:
	LD	HL,-2
	CALL	__frameset
; 1010		char oldr, oldc;
; 1011		
; 1012		oldr = cur_row;
	LD	A,(_cur_row)
	LD	(IX+-1),A
; 1013		oldc = cur_col;
	LD	A,(_cur_col)
	LD	(IX+-2),A
; 1014		
; 1015		p_curr = p_root->p_next;
	LD	IY,(_p_root)
	LD	BC,(IY+3)
	LD	(_p_curr),BC
; 1016		
; 1017		cur_line = 1;
	LD	BC,1
	LD	(_cur_line),BC
; 1018		cur_char = 1;
	LD	(_cur_char),BC
; 1019		cur_row = 0;
	LD	BC,0
	LD	(_cur_row),BC
; 1020		cur_col = 0;
	LD	(_cur_col),BC
; 1021		
; 1022		paintall();
	CALL	_paintall
; 1023		
; 1024		plot_char(oldc, oldr, scn_phys[oldr][oldc]);
	LD	A,(IX+-1)
	SEXT	HL
	LD	L,(IX+-1)
	LD	BC,HL
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_scn_phys
	ADD	HL,BC
	LD	BC,HL
	LD	A,(IX+-2)
	SEXT	HL
	LD	L,(IX+-2)
	ADD	HL,BC
	LD	C,(HL)
	LD	B,0
	PUSH	BC
	LD	C,(IX+-1)
	PUSH	BC
	LD	C,(IX+-2)
	PUSH	BC
	CALL	_plot_char
	POP	BC
	POP	BC
	POP	BC
; 1025	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _do_top ***************************
;Name                         Addr/Register   Size   Type
;_scn_phys                           STATIC   4000   variable
;_plot_char                          IMPORT  -----   function
;_paintall                           IMPORT  -----   function
;_cur_char                           STATIC      3   variable
;_cur_line                           STATIC      3   variable
;_p_curr                             STATIC      3   variable
;_p_root                             STATIC      3   variable
;_cur_col                            STATIC      3   variable
;_cur_row                            STATIC      3   variable
;oldc                                  IX-2      1   variable
;oldr                                  IX-1      1   variable


; Stack Frame Size: 8 (bytes)
;       Spill Code: 0 (instruction)


; 1026	
; 1027	/* Jump to bottom of document. */
; 1028	void do_bot(char paint)
; 1029	{
_do_bot:
	LD	HL,-2
	CALL	__frameset
; 1030		char oldr, oldc;
; 1031		
; 1032		oldr = cur_row;
	LD	A,(_cur_row)
	LD	(IX+-1),A
; 1033		oldc = cur_col;
	LD	A,(_cur_col)
	LD	(IX+-2),A
; 1034		
; 1035		p_curr = p_root;
	LD	BC,(_p_root)
	LD	(_p_curr),BC
; 1036		
; 1037		cur_line = numlines + 1;
	LD	BC,(_numlines)
	INC	BC
	LD	(_cur_line),BC
; 1038		cur_row = numlines;
	LD	BC,(_numlines)
	LD	(_cur_row),BC
; 1039		cur_char = 1;
	LD	BC,1
	LD	(_cur_char),BC
; 1040		cur_col = 0;
	LD	BC,0
	LD	(_cur_col),BC
; 1041		
; 1042		if (cur_row > SCNROWS - 1)
	LD	BC,(_numlines)
	OR	A,A
	LD	HL,49
	SBC	HL,BC
	JP	P,L__175
	JP	PE,L_233
	JR	L__176
L__175:
	JP	PO,L_233
L__176:
; 1043			cur_row = SCNROWS - 1;
	LD	BC,49
	LD	(_cur_row),BC
L_233:
; 1044		
; 1045		if (paint)
	LD	A,(IX+6)
	OR	A,A
	JR	Z,L_234
; 1046			paintall();
	CALL	_paintall
L_234:
; 1047		
; 1048		plot_char(oldc, oldr, scn_phys[oldr][oldc]);
	LD	A,(IX+-1)
	SEXT	HL
	LD	L,(IX+-1)
	LD	BC,HL
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_scn_phys
	ADD	HL,BC
	LD	BC,HL
	LD	A,(IX+-2)
	SEXT	HL
	LD	L,(IX+-2)
	ADD	HL,BC
	LD	C,(HL)
	LD	B,0
	PUSH	BC
	LD	C,(IX+-1)
	PUSH	BC
	LD	C,(IX+-2)
	PUSH	BC
	CALL	_plot_char
	POP	BC
	POP	BC
	POP	BC
; 1049	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _do_bot ***************************
;Name                         Addr/Register   Size   Type
;_scn_phys                           STATIC   4000   variable
;_plot_char                          IMPORT  -----   function
;_paintall                           IMPORT  -----   function
;_cur_char                           STATIC      3   variable
;_cur_line                           STATIC      3   variable
;_numlines                           STATIC      3   variable
;_p_curr                             STATIC      3   variable
;_p_root                             STATIC      3   variable
;_cur_col                            STATIC      3   variable
;_cur_row                            STATIC      3   variable
;oldc                                  IX-2      1   variable
;oldr                                  IX-1      1   variable
;paint                                 IX+6      1   parameter


; Stack Frame Size: 11 (bytes)
;       Spill Code: 0 (instruction)


; 1050	
; 1051	/* Type the specified character. */
; 1052	void do_chr(char ch)
; 1053	{
_do_chr:
	LD	HL,-3
	CALL	__frameset
; 1054		register int i;
; 1055		
; 1056		if (p_curr == p_root)
	LD	BC,(_p_root)
	LD	HL,(_p_curr)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_246
; 1057			return;
; 1058	
; 1059		if (cur_char == MAXLNLEN + 1)
	LD	BC,81
	LD	HL,(_cur_char)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_239
; 1060		{
; 1061			Show_Cursor();
	CALL	_Show_Cursor
; 1062			
; 1063			return;
	JR	L_246
; 1064		}
L_239:
; 1065		
; 1066		tx_get(p_curr);	
	LD	BC,(_p_curr)
	PUSH	BC
	CALL	_tx_get
	POP	BC
; 1067		
; 1068		if (InsertMode != 0)
	LD	A,(_InsertMode)
	OR	A,A
	JR	Z,L_245
	LD	BC,79
	LD	(IX+-3),BC
; 1069		{
; 1070			for (i = MAXLNLEN - 1; i > cur_char - 1; i--)
	JR	L_243
L_241:
; 1071				linbuf[i] = linbuf[i - 1];
	LD	BC,(IX+-3)
	DEC	BC
	LD	HL,BC
	LD	DE,_linbuf
	ADD	HL,DE
	LD	IY,HL
	LD	HL,(IX+-3)
	ADD	HL,DE
	LD	A,(IY)
	LD	(HL),A
	LD	(IX+-3),BC
L_243:
	LD	HL,(_cur_char)
	DEC	HL
	OR	A,A
	LD	BC,(IX+-3)
	SBC	HL,BC
	JP	M,L_241
; 1072		}	
L_245:
; 1073		
; 1074		linbuf[cur_char - 1] = (char)(ch);
	LD	HL,(_cur_char)
	DEC	HL
	LD	BC,_linbuf
	ADD	HL,BC
	LD	A,(IX+6)
	LD	(HL),A
; 1075		
; 1076		tx_put(p_curr);
	LD	BC,(_p_curr)
	PUSH	BC
	CALL	_tx_put
	POP	BC
; 1077		
; 1078		do_crt();
	CALL	_do_crt
; 1079		paintrow();
	CALL	_paintrow
; 1080	}
L_246:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _do_chr ***************************
;Name                         Addr/Register   Size   Type
;_paintrow                           IMPORT  -----   function
;_do_crt                             IMPORT  -----   function
;_tx_put                             IMPORT  -----   function
;_linbuf                             STATIC     90   variable
;_InsertMode                         STATIC      1   variable
;_tx_get                             IMPORT  -----   function
;_Show_Cursor                        IMPORT  -----   function
;_cur_char                           STATIC      3   variable
;_p_root                             STATIC      3   variable
;_p_curr                             STATIC      3   variable
;i                                     IX-3      3   variable
;ch                                    IX+6      1   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


; 1081	
; 1082	/* Delete character. */
; 1083	void do_dch(void)
; 1084	{
_do_dch:
	LD	HL,-3
	CALL	__frameset
; 1085		register int i;
; 1086		
; 1087		if (p_curr == p_root)
	LD	BC,(_p_root)
	LD	HL,(_p_curr)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_254
; 1088			return;
; 1089		
; 1090		tx_get(p_curr);
	LD	BC,(_p_curr)
	PUSH	BC
	CALL	_tx_get
	POP	BC
	LD	BC,(_cur_char)
	DEC	BC
	LD	(IX+-3),BC
; 1091		
; 1092		for (i = cur_char - 1; i < MAXLNLEN - 1; i++)
	JR	L_252
L_250:
; 1093			linbuf[i] = linbuf[i + 1];
	LD	BC,(IX+-3)
	INC	BC
	LD	HL,BC
	LD	DE,_linbuf
	ADD	HL,DE
	LD	IY,HL
	LD	HL,(IX+-3)
	ADD	HL,DE
	LD	A,(IY)
	LD	(HL),A
	LD	(IX+-3),BC
L_252:
	LD	BC,79
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JP	M,L__185
	JP	PE,L_250
	JR	L__186
L__185:
	JP	PO,L_250
L__186:
; 1094		
; 1095		linbuf[MAXLNLEN - 1] = ' ';
	LD	HL,_linbuf+79
	LD	(HL),32
; 1096		
; 1097		tx_put(p_curr);
	LD	BC,(_p_curr)
	PUSH	BC
	CALL	_tx_put
	POP	BC
; 1098		
; 1099		paintrow();
	CALL	_paintrow
; 1100	}
L_254:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _do_dch ***************************
;Name                         Addr/Register   Size   Type
;_paintrow                           IMPORT  -----   function
;_tx_put                             IMPORT  -----   function
;_linbuf                             STATIC     90   variable
;_cur_char                           STATIC      3   variable
;_tx_get                             IMPORT  -----   function
;_p_root                             STATIC      3   variable
;_p_curr                             STATIC      3   variable
;i                                     IX-3      3   variable


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


; 1101	
; 1102	/* Insert line. */
; 1103	void do_iln(void)
; 1104	{
_do_iln:
; 1105		paintrow();
	CALL	_paintrow
; 1106		
; 1107		if (cur_line < numlines)
	LD	BC,(_numlines)
	LD	HL,(_cur_line)
	OR	A,A
	SBC	HL,BC
	JP	P,L__191
	JP	PE,L_256
	JR	L__192
L__191:
	JP	PO,L_256
L__192:
; 1108		{
; 1109			do_cdw();
	CALL	_do_cdw
; 1110			
; 1111			tx_ins(p_curr, "");
	LD	BC,L__189
	PUSH	BC
	LD	BC,(_p_curr)
	PUSH	BC
	CALL	_tx_ins
	POP	BC
	POP	BC
; 1112			
; 1113			p_curr = p_curr->p_prev;
	LD	IY,(_p_curr)
	LD	BC,(IY+0)
	LD	(_p_curr),BC
; 1114		}		
; 1115		else
	JR	L_257
L_256:
; 1116		{
; 1117			tx_ins(p_root, "");		
	LD	BC,L__190
	PUSH	BC
	LD	BC,(_p_root)
	PUSH	BC
	CALL	_tx_ins
	POP	BC
	POP	BC
; 1118			
; 1119			do_bot(0);
	LD	BC,0
	PUSH	BC
	CALL	_do_bot
	POP	BC
; 1120		}
L_257:
; 1121		
; 1122		cur_char = 1;
	LD	BC,1
	LD	(_cur_char),BC
; 1123		cur_col = 0;
	LD	BC,0
	LD	(_cur_col),BC
; 1124		
; 1125		paintall();	
	CALL	_paintall
; 1126	}
	RET	


;**************************** _do_iln ***************************
;Name                         Addr/Register   Size   Type
;_paintall                           IMPORT  -----   function
;_cur_col                            STATIC      3   variable
;_cur_char                           STATIC      3   variable
;_do_bot                             IMPORT  -----   function
;_p_root                             STATIC      3   variable
;_p_curr                             STATIC      3   variable
;_tx_ins                             IMPORT  -----   function
;_do_cdw                             IMPORT  -----   function
;_numlines                           STATIC      3   variable
;_cur_line                           STATIC      3   variable
;_paintrow                           IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__189:
	DB	0
L__190:
	DB	0
	SEGMENT CODE
; 1127	
; 1128	/* Delete line. */
; 1129	void do_dln(void)
; 1130	{
_do_dln:
	LD	HL,-3
	CALL	__frameset
; 1131		p_line_t save = p_curr->p_next;
	LD	IY,(_p_curr)
	LD	BC,(IY+3)
	LD	(IX+-3),BC
; 1132		
; 1133		if (p_curr == p_root)
	LD	BC,(_p_root)
	LD	HL,(_p_curr)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_261
; 1134			return;
; 1135		
; 1136		tx_del(p_curr);
	LD	BC,(_p_curr)
	PUSH	BC
	CALL	_tx_del
	POP	BC
; 1137		
; 1138		p_curr = save;
	LD	BC,(IX+-3)
	LD	(_p_curr),BC
; 1139		
; 1140		paintall();
	CALL	_paintall
; 1141	}
L_261:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _do_dln ***************************
;Name                         Addr/Register   Size   Type
;_paintall                           IMPORT  -----   function
;_tx_del                             IMPORT  -----   function
;_p_root                             STATIC      3   variable
;_p_curr                             STATIC      3   variable
;save                                  IX-3      3   variable


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


; 1142	
; 1143	/* Delete. */
; 1144	void do_del(void)
; 1145	{
_do_del:
; 1146		if (cur_char == 1)
	LD	BC,1
	LD	HL,(_cur_char)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_265
; 1147			if (strlen(p_curr->p_data) <= 0)
	LD	IY,(_p_curr)
	LD	BC,(IY+6)
	PUSH	BC
	CALL	_strlen
	POP	BC
	LD	BC,HL
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	JR	NC,L_266
; 1148				return;
; 1149			else
; 1150			{
; 1151				do_enhanced_del();
	CALL	_do_enhanced_del
; 1152				
; 1153				return;
	JR	L_266
; 1154			}
L_265:
; 1155		
; 1156		do_clf();
	CALL	_do_clf
; 1157		
; 1158		do_dch();
	CALL	_do_dch
; 1159	}
L_266:
	RET	


;**************************** _do_del ***************************
;Name                         Addr/Register   Size   Type
;_do_dch                             IMPORT  -----   function
;_do_clf                             IMPORT  -----   function
;_do_enhanced_del                    IMPORT  -----   function
;_p_curr                             STATIC      3   variable
;_strlen                             IMPORT  -----   function
;_cur_char                           STATIC      3   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


; 1160	
; 1161	/* Enhanced Delete. Can join current line with previous line. */
; 1162	void do_enhanced_del(void)
; 1163	{
_do_enhanced_del:
	LD	HL,-82
	CALL	__frameset
; 1164		char app[MAXLNLEN], i, oldPos;
; 1165		
; 1166		if (cur_line == 1)
	LD	BC,1
	LD	HL,(_cur_line)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_268
; 1167		{
; 1168			Show_Cursor();
	CALL	_Show_Cursor
; 1169			
; 1170			return;		
	JR	L_274
; 1171		}
L_268:
; 1172		
; 1173		memset(app, 0, MAXLNLEN);	
	LD	BC,80
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PEA	IX+-82
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
; 1174		
; 1175		memmove(app, p_curr->p_data, strlen(p_curr->p_data));
	LD	IY,(_p_curr)
	LD	BC,(IY+6)
	PUSH	BC
	CALL	_strlen
	POP	BC
	PUSH	HL
	LD	IY,(_p_curr)
	LD	BC,(IY+6)
	PUSH	BC
	PEA	IX+-82
	CALL	_memmove
	POP	BC
	POP	BC
	POP	BC
; 1176		
; 1177		do_dln();	
	CALL	_do_dln
; 1178		
; 1179		do_cup();
	CALL	_do_cup
; 1180		do_endline();
	CALL	_do_endline
; 1181		
; 1182		oldPos = cur_col;
	LD	A,(_cur_col)
	LD	(IX+-2),A
	LD	(IX+-1),0
; 1183		
; 1184		for (i = 0; i < strlen(app); i++)
	JR	L_272
L_270:
; 1185			do_chr(app[i]);	
	LD	A,(IX+-1)
	SEXT	HL
	LD	L,(IX+-1)
	LD	BC,HL
	LEA	HL,IX+-82
	ADD	HL,BC
	LD	C,(HL)
	LD	B,0
	PUSH	BC
	CALL	_do_chr
	POP	BC
	INC	(IX+-1)
L_272:
	PEA	IX+-82
	CALL	_strlen
	POP	BC
	LD	A,(IX+-1)
	LD	BC,HL
	SEXT	HL
	LD	L,(IX+-1)
	OR	A,A
	SBC	HL,BC
	JR	C,L_270
; 1186		
; 1187		paintrow();
	CALL	_paintrow
; 1188		
; 1189		cur_col = oldPos;
	LD	A,(IX+-2)
	SEXT	HL
	LD	L,(IX+-2)
	LD	(_cur_col),HL
; 1190		cur_char = cur_col + 1;
	LD	A,(IX+-2)
	SEXT	HL
	LD	L,(IX+-2)
	INC	HL
	LD	(_cur_char),HL
; 1191	}
L_274:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _do_enhanced_del ***************************
;Name                         Addr/Register   Size   Type
;_cur_char                           STATIC      3   variable
;_paintrow                           IMPORT  -----   function
;_do_chr                             IMPORT  -----   function
;_cur_col                            STATIC      3   variable
;_do_endline                         IMPORT  -----   function
;_do_cup                             IMPORT  -----   function
;_do_dln                             IMPORT  -----   function
;_p_curr                             STATIC      3   variable
;_strlen                             IMPORT  -----   function
;_memmove                            IMPORT  -----   function
;_memset                             IMPORT  -----   function
;_Show_Cursor                        IMPORT  -----   function
;_cur_line                           STATIC      3   variable
;app                                  IX-82     80   variable
;oldPos                                IX-2      1   variable
;i                                     IX-1      1   variable


; Stack Frame Size: 88 (bytes)
;       Spill Code: 0 (instruction)


; 1192	
; 1193	/* Go to the start of current line. */
; 1194	void do_home(void)
; 1195	{
_do_home:
	LD	HL,-2
	CALL	__frameset
; 1196		char ch, oldcol;
; 1197		
; 1198		if (p_curr == p_root)
	LD	BC,(_p_root)
	LD	HL,(_p_curr)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_277
; 1199			return;
; 1200		
; 1201		ch = scn_phys[cur_row][cur_col];
	LD	HL,(_cur_row)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,(_cur_row)
	ADD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_scn_phys
	ADD	HL,BC
	LD	BC,(_cur_col)
	ADD	HL,BC
	LD	A,(HL)
	LD	(IX+-1),A
; 1202		oldcol = cur_col;
	LD	A,(_cur_col)
	LD	(IX+-2),A
; 1203		
; 1204		cur_char = 1;
	LD	BC,1
	LD	(_cur_char),BC
; 1205		cur_col = 0;
	LD	BC,0
	LD	(_cur_col),BC
; 1206		
; 1207		plot_char(oldcol, cur_row, ch);
	LD	C,(IX+-1)
	LD	A,(_cur_row)
	LD	B,0
	PUSH	BC
	LD	C,A
	PUSH	BC
	LD	C,(IX+-2)
	PUSH	BC
	CALL	_plot_char
	POP	BC
	POP	BC
	POP	BC
; 1208	}
L_277:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _do_home ***************************
;Name                         Addr/Register   Size   Type
;_plot_char                          IMPORT  -----   function
;_cur_char                           STATIC      3   variable
;_cur_col                            STATIC      3   variable
;_cur_row                            STATIC      3   variable
;_scn_phys                           STATIC   4000   variable
;_p_root                             STATIC      3   variable
;_p_curr                             STATIC      3   variable
;oldcol                                IX-2      1   variable
;ch                                    IX-1      1   variable


; Stack Frame Size: 8 (bytes)
;       Spill Code: 0 (instruction)


; 1209	
; 1210	/* Go to the end of current line. */
; 1211	void do_endline(void)
; 1212	{
_do_endline:
	LD	HL,-3
	CALL	__frameset
; 1213		char len, ch, oldcol;
; 1214		
; 1215		if (p_curr == p_root)
	LD	BC,(_p_root)
	LD	HL,(_p_curr)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_280
; 1216			return;
; 1217		
; 1218		len = strlen(p_curr->p_data);	
	LD	IY,(_p_curr)
	LD	BC,(IY+6)
	PUSH	BC
	CALL	_strlen
	POP	BC
	LD	(IX+-1),L
; 1219		
; 1220		ch = scn_phys[cur_row][cur_col];
	LD	HL,(_cur_row)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,(_cur_row)
	ADD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_scn_phys
	ADD	HL,BC
	LD	BC,(_cur_col)
	ADD	HL,BC
	LD	A,(HL)
	LD	(IX+-2),A
; 1221		oldcol = cur_col;
	LD	A,(_cur_col)
	LD	(IX+-3),A
; 1222		
; 1223		cur_col = len;
	LD	A,(IX+-1)
	SEXT	HL
	LD	L,(IX+-1)
	LD	(_cur_col),HL
; 1224		cur_char = len + 1;
	LD	A,(IX+-1)
	SEXT	HL
	LD	L,(IX+-1)
	INC	HL
	LD	(_cur_char),HL
; 1225		
; 1226		plot_char(oldcol, cur_row, ch);
	LD	C,(IX+-2)
	LD	A,(_cur_row)
	LD	B,0
	PUSH	BC
	LD	C,A
	PUSH	BC
	LD	C,(IX+-3)
	PUSH	BC
	CALL	_plot_char
	POP	BC
	POP	BC
	POP	BC
; 1227	}
L_280:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _do_endline ***************************
;Name                         Addr/Register   Size   Type
;_plot_char                          IMPORT  -----   function
;_cur_char                           STATIC      3   variable
;_cur_col                            STATIC      3   variable
;_cur_row                            STATIC      3   variable
;_scn_phys                           STATIC   4000   variable
;_strlen                             IMPORT  -----   function
;_p_root                             STATIC      3   variable
;_p_curr                             STATIC      3   variable
;oldcol                                IX-3      1   variable
;ch                                    IX-2      1   variable
;len                                   IX-1      1   variable


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


; 1228	
; 1229	/* Set insert or overwrite mode */
; 1230	void do_ins(void)
; 1231	{
_do_ins:
; 1232		if (InsertMode != 0)
	LD	A,(_InsertMode)
	OR	A,A
	JR	Z,L_282
; 1233			InsertMode = 0;
	XOR	A,A
	LD	(_InsertMode),A
; 1234		else
	JR	L_283
L_282:
; 1235			InsertMode = 1;
	LD	A,1
	LD	(_InsertMode),A
L_283:
; 1236		
; 1237		ShowInsertMode();
	CALL	_ShowInsertMode
; 1238		
; 1239		gotoxy(cur_col, cur_row);
	LD	A,(_cur_row)
	LD	C,A
	LD	A,(_cur_col)
	LD	B,0
	PUSH	BC
	LD	C,A
	PUSH	BC
	CALL	_gotoxy
	POP	BC
	POP	BC
; 1240		
; 1241		Show_Cursor();
	CALL	_Show_Cursor
; 1242	}
	RET	


;**************************** _do_ins ***************************
;Name                         Addr/Register   Size   Type
;_Show_Cursor                        IMPORT  -----   function
;_cur_col                            STATIC      3   variable
;_cur_row                            STATIC      3   variable
;_gotoxy                             IMPORT  -----   function
;_ShowInsertMode                     IMPORT  -----   function
;_InsertMode                         STATIC      1   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


; 1243	
; 1244	/* Redraws the virtual screen from scratch from the current settings. */
; 1245	void paintall(void)
; 1246	{
_paintall:
	LD	HL,-8
	CALL	__frameset
; 1247		register unsigned char r;
; 1248		p_line_t p = p_curr;
	LD	BC,(_p_curr)
	LD	(IX+-4),BC
; 1249		int left_pos = cur_char - cur_col;
	LD	HL,(_cur_char)
	LD	BC,(_cur_col)
	OR	A,A
	SBC	HL,BC
	LD	(IX+-8),HL
	LD	(IX+-1),0
; 1250		unsigned char len;
; 1251		
; 1252		for (r = 0; r < cur_row; r++)
	JR	L_288
L_286:
; 1253			p = p->p_prev;
	LD	IY,(IX+-4)
	LD	BC,(IY+0)
	LD	(IX+-4),BC
	INC	(IX+-1)
L_288:
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,(_cur_row)
	SBC	HL,BC
	JP	M,L_286
; 1254		
; 1255		sc_clr();
	CALL	_sc_clr
	LD	(IX+-1),0
; 1256		
; 1257		for (r = 0; r < SCNROWS; r++)
	JR	L_299
L_297:
; 1258		{
; 1259			if (p == p_root)
	LD	BC,(IX+-4)
	LD	HL,(_p_root)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_292
; 1260			{
; 1261				sc_str(r, 0, "<eof>");
	LD	BC,L__210
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	CALL	_sc_str
	POP	BC
	POP	BC
	POP	BC
; 1262				
; 1263				do_cup();
	CALL	_do_cup
; 1264				
; 1265				break;
	JR	L_300
; 1266			}
L_292:
; 1267			
; 1268			len = strlen(p->p_data);
	LD	IY,(IX+-4)
	LD	BC,(IY+6)
	PUSH	BC
	CALL	_strlen
	POP	BC
	LD	(IX+-5),L
; 1269			
; 1270			if (len >= left_pos)
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,(IX+-8)
	SBC	HL,BC
	JP	M,L__214
	JP	PE,L_295
	JR	L__215
L__214:
	JP	PO,L_295
L__215:
; 1271				sc_str(r, 0, p->p_data + (left_pos - 1));
	LD	BC,(IX+-8)
	LD	IY,(IX+-4)
	LD	HL,(IY+6)
	DEC	BC
	ADD	HL,BC
	PUSH	HL
	LD	BC,0
	PUSH	BC
	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	CALL	_sc_str
	POP	BC
	POP	BC
	POP	BC
; 1272			else
	JR	L_296
L_295:
; 1273				if (len == 0)
	LD	A,(IX+-5)
	OR	A,A
	JR	NZ,L_296
; 1274					plot_char(0, r, ' ');
	LD	BC,32
	PUSH	BC
	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	LD	BC,0
	PUSH	BC
	CALL	_plot_char
	POP	BC
	POP	BC
	POP	BC
L_296:
; 1275			
; 1276			p = p->p_next;
	LD	IY,(IX+-4)
	LD	BC,(IY+3)
	LD	(IX+-4),BC
	INC	(IX+-1)
; 1277		}
L_299:
	LD	A,(IX+-1)
	CP	A,50
	JR	C,L_297
L_300:
; 1278		
; 1279		te_mov(cur_row, cur_col);
	LD	A,(_cur_col)
	LD	C,A
	LD	A,(_cur_row)
	LD	B,0
	PUSH	BC
	LD	C,A
	PUSH	BC
	CALL	_te_mov
	POP	BC
	POP	BC
; 1280	
; 1281		Show_Cursor();
	CALL	_Show_Cursor
; 1282	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _paintall ***************************
;Name                         Addr/Register   Size   Type
;_Show_Cursor                        IMPORT  -----   function
;_te_mov                             IMPORT  -----   function
;_plot_char                          IMPORT  -----   function
;_strlen                             IMPORT  -----   function
;_do_cup                             IMPORT  -----   function
;_sc_str                             IMPORT  -----   function
;_p_root                             STATIC      3   variable
;_sc_clr                             IMPORT  -----   function
;_cur_row                            STATIC      3   variable
;_cur_col                            STATIC      3   variable
;_cur_char                           STATIC      3   variable
;_p_curr                             STATIC      3   variable
;left_pos                              IX-8      3   variable
;len                                   IX-5      1   variable
;p                                     IX-4      3   variable
;r                                     IX-1      1   variable


; Stack Frame Size: 14 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__210:
	DB	"<eof>"
	DB	0
	SEGMENT CODE
; 1283	
; 1284	/* Redraws the current row of the virtual screen */
; 1285	/* from scratch from the current settings.       */
; 1286	void paintrow(void)
; 1287	{
_paintrow:
	LD	HL,-2
	CALL	__frameset
; 1288		unsigned char left_pos = cur_char - cur_col;
	LD	A,(_cur_char)
	LD	B,A
	LD	A,(_cur_col)
	LD	C,A
	LD	A,B
	SUB	A,C
	LD	(IX+-1),A
; 1289		char len;
; 1290		
; 1291		len = strlen(p_curr->p_data);
	LD	IY,(_p_curr)
	LD	BC,(IY+6)
	PUSH	BC
	CALL	_strlen
	POP	BC
	LD	(IX+-2),L
; 1292		
; 1293		sc_crw(cur_row);
	LD	A,(_cur_row)
	LD	C,A
	LD	B,0
	PUSH	BC
	CALL	_sc_crw
	POP	BC
; 1294		
; 1295		if (p_curr == p_root)
	LD	BC,(_p_root)
	LD	HL,(_p_curr)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_304
; 1296			sc_str(cur_row, 0, "<eof>");
	LD	BC,L__218
	PUSH	BC
	LD	A,(_cur_row)
	LD	C,A
	LD	DE,0
	PUSH	DE
	LD	B,0
	PUSH	BC
	CALL	_sc_str
	POP	BC
	POP	BC
	POP	BC
; 1297		else
	JR	L_305
L_304:
; 1298			if (len >= left_pos)
	LD	A,(IX+-2)
	CP	A,(IX+-1)
	JR	C,L_305
; 1299			{
; 1300				sc_str(cur_row, 0, p_curr->p_data + (left_pos - 1));			
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	IY,(_p_curr)
	LD	HL,(IY+6)
	DEC	BC
	ADD	HL,BC
	PUSH	HL
	LD	A,(_cur_row)
	LD	C,A
	LD	DE,0
	PUSH	DE
	LD	B,0
	PUSH	BC
	CALL	_sc_str
	POP	BC
	POP	BC
	POP	BC
; 1301		
; 1302				gotoxy(len, cur_row);
	LD	A,(_cur_row)
	LD	C,A
	LD	B,0
	PUSH	BC
	LD	C,(IX+-2)
	PUSH	BC
	CALL	_gotoxy
	POP	BC
	POP	BC
; 1303				
; 1304				clreol();
	CALL	_clreol
; 1305			}
; 1306	}
L_305:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _paintrow ***************************
;Name                         Addr/Register   Size   Type
;_clreol                             IMPORT  -----   function
;_gotoxy                             IMPORT  -----   function
;_sc_str                             IMPORT  -----   function
;_p_root                             STATIC      3   variable
;_cur_row                            STATIC      3   variable
;_sc_crw                             IMPORT  -----   function
;_p_curr                             STATIC      3   variable
;_strlen                             IMPORT  -----   function
;_cur_col                            STATIC      3   variable
;_cur_char                           STATIC      3   variable
;len                                   IX-2      1   variable
;left_pos                              IX-1      1   variable


; Stack Frame Size: 8 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__218:
	DB	"<eof>"
	DB	0
	SEGMENT CODE
; 1307	
; 1308	/* Show curson on screen. */
; 1309	void Show_Cursor(void)
; 1310	{
_Show_Cursor:
; 1311		asm ("push ix");
push ix
; 1312		asm ("ld a, kr_draw_cursor");
ld a, kr_draw_cursor
; 1313		asm ("call.lil prose_kernal");
call.lil prose_kernal
; 1314		asm ("pop ix");	
pop ix
; 1315	}
	RET	


;**************************** _Show_Cursor ***************************
;Name                         Addr/Register   Size   Type


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


; 1316	
; 1317	/* Show PROTED men */
; 1318	void ShowMenu(void)
; 1319	{
_ShowMenu:
; 1320		Enable_Back_Color();
	CALL	_Enable_Back_Color
; 1321		
; 1322		gotoxy(0, 50);	
	LD	BC,50
	PUSH	BC
	LD	BC,0
	PUSH	BC
	CALL	_gotoxy
	POP	BC
	POP	BC
; 1323		print("+==================================]PROTED[====================================+");
	LD	BC,L__222
	PUSH	BC
	CALL	_print
	POP	BC
; 1324		print("| Ln:       , Col:                                                             |");
	LD	BC,L__223
	PUSH	BC
	CALL	_print
	POP	BC
; 1325		print("|                                                                              |");
	LD	BC,L__224
	PUSH	BC
	CALL	_print
	POP	BC
; 1326		print("| Command  shortcuts:                                                          |");
	LD	BC,L__225
	PUSH	BC
	CALL	_print
	POP	BC
; 1327		print("| Ctrl + L: insert a line.   Ctrl + E: end of text.   Ctrl + K: delete a line. |");
	LD	BC,L__226
	PUSH	BC
	CALL	_print
	POP	BC
; 1328		print("| Ctrl + N: redraw screen.   Ctrl + T: top of file.   Ctrl + S: save file.     |");
	LD	BC,L__227
	PUSH	BC
	CALL	_print
	POP	BC
; 1329		print("| Ctrl + B: break a line.    Ctrl + R: reload file.   Ctrl + Q: quit to PROSE. |");
	LD	BC,L__228
	PUSH	BC
	CALL	_print
	POP	BC
; 1330		print("|      Key enabled: Tab, Cursor Keys, PgUp, PgDown, Home, End, Del, Ins.       |");
	LD	BC,L__229
	PUSH	BC
	CALL	_print
	POP	BC
; 1331		print("+==============================================================================+");
	LD	BC,L__230
	PUSH	BC
	CALL	_print
	POP	BC
; 1332		
; 1333		Disable_Back_Color();
	CALL	_Disable_Back_Color
; 1334	}
	RET	


;**************************** _ShowMenu ***************************
;Name                         Addr/Register   Size   Type
;_Disable_Back_Color                 IMPORT  -----   function
;_print                              IMPORT  -----   function
;_gotoxy                             IMPORT  -----   function
;_Enable_Back_Color                  IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__222:
	DB	"+==================================]PROTED[====================================+"
	DB	0
L__223:
	DB	"| Ln:       , Col:                                                             |"
	DB	0
L__224:
	DB	"|                                                                              |"
	DB	0
L__225:
	DB	"| Command  shortcuts:                                                          |"
	DB	0
L__226:
	DB	"| Ctrl + L: insert a line.   Ctrl + E: end of text.   Ctrl + K: delete a line. |"
	DB	0
L__227:
	DB	"| Ctrl + N: redraw screen.   Ctrl + T: top of file.   Ctrl + S: save file.     |"
	DB	0
L__228:
	DB	"| Ctrl + B: break a line.    Ctrl + R: reload file.   Ctrl + Q: quit to PROSE. |"
	DB	0
L__229:
	DB	"|      Key enabled: Tab, Cursor Keys, PgUp, PgDown, Home, End, Del, Ins.       |"
	DB	0
L__230:
	DB	"+==============================================================================+"
	DB	0
	SEGMENT CODE
; 1335	
; 1336	/* Show Type Mode */
; 1337	void ShowInsertMode(void)
; 1338	{
_ShowInsertMode:
; 1339		Enable_Back_Color();
	CALL	_Enable_Back_Color
; 1340		
; 1341		gotoxy(54, 51);	
	LD	BC,51
	PUSH	BC
	LD	BC,54
	PUSH	BC
	CALL	_gotoxy
	POP	BC
	POP	BC
; 1342		print("                     ");
	LD	BC,L__232
	PUSH	BC
	CALL	_print
	POP	BC
; 1343		
; 1344		gotoxy(54, 51);
	LD	BC,51
	PUSH	BC
	LD	BC,54
	PUSH	BC
	CALL	_gotoxy
	POP	BC
	POP	BC
; 1345		print("Type mode: ");
	LD	BC,L__233
	PUSH	BC
	CALL	_print
	POP	BC
; 1346		
; 1347		if (InsertMode)
	LD	A,(_InsertMode)
	OR	A,A
	JR	Z,L_309
; 1348			print("Insert");
	LD	BC,L__235
	PUSH	BC
	CALL	_print
	POP	BC
; 1349		else
	JR	L_310
L_309:
; 1350			print("Overwrite");
	LD	BC,L__236
	PUSH	BC
	CALL	_print
	POP	BC
L_310:
; 1351		
; 1352		Disable_Back_Color();
	CALL	_Disable_Back_Color
; 1353	}
	RET	


;**************************** _ShowInsertMode ***************************
;Name                         Addr/Register   Size   Type
;_Disable_Back_Color                 IMPORT  -----   function
;_InsertMode                         STATIC      1   variable
;_print                              IMPORT  -----   function
;_gotoxy                             IMPORT  -----   function
;_Enable_Back_Color                  IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__232:
	DB	"                     "
	DB	0
L__233:
	DB	"Type mode: "
	DB	0
L__235:
	DB	"Insert"
	DB	0
L__236:
	DB	"Overwrite"
	DB	0
	SEGMENT CODE
; 1354	
; 1355	/* Enable the background color for print string */
; 1356	void Enable_Back_Color(void)
; 1357	{
_Enable_Back_Color:
; 1358		asm ("push ix");
push ix
; 1359		asm ("ld E, E7h");
ld E, E7h
; 1360		asm ("ld a, kr_set_pen");
ld a, kr_set_pen
; 1361		asm ("call.lil prose_kernal");
call.lil prose_kernal
; 1362		asm ("pop ix");
pop ix
; 1363	}
	RET	


;**************************** _Enable_Back_Color ***************************
;Name                         Addr/Register   Size   Type


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


; 1364	
; 1365	/* Disable the background color for print string */
; 1366	void Disable_Back_Color(void)
; 1367	{
_Disable_Back_Color:
; 1368		asm ("push ix");
push ix
; 1369		asm ("ld E, 07h");
ld E, 07h
; 1370		asm ("ld a, kr_set_pen");
ld a, kr_set_pen
; 1371		asm ("call.lil prose_kernal");
call.lil prose_kernal
; 1372		asm ("pop ix");
pop ix
; 1373	}
	RET	


;**************************** _Disable_Back_Color ***************************
;Name                         Addr/Register   Size   Type


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


; 1374	
; 1375	/* Main edit loop */
; 1376	void edit(void)
; 1377	{
_edit:
	LD	HL,-1
	CALL	__frameset
; 1378		cur_row = 0;
	LD	BC,0
	LD	(_cur_row),BC
; 1379		cur_col = 0;
	LD	(_cur_col),BC
; 1380		cur_line = 1;
	LD	BC,1
	LD	(_cur_line),BC
; 1381		cur_char = 1;
	LD	(_cur_char),BC
; 1382		InsertMode = 1;
	LD	A,1
	LD	(_InsertMode),A
; 1383		p_curr = p_root->p_next;	
	LD	IY,(_p_root)
	LD	BC,(IY+3)
	LD	(_p_curr),BC
; 1384		
; 1385		paintall();
	CALL	_paintall
; 1386		
; 1387		sc_fup();
	CALL	_sc_fup
; 1388		
; 1389		ShowInsertMode();
	CALL	_ShowInsertMode
; 1390		
; 1391		while (TRUE)
L_346:
; 1392		{
; 1393			char ch;
; 1394			
; 1395			sc_upd();
	CALL	_sc_upd
; 1396			
; 1397			Show_Cursor_Position();
	CALL	_Show_Cursor_Position
; 1398			
; 1399			te_mov(cur_row, cur_col);
	LD	A,(_cur_col)
	LD	C,A
	LD	A,(_cur_row)
	LD	B,0
	PUSH	BC
	LD	C,A
	PUSH	BC
	CALL	_te_mov
	POP	BC
	POP	BC
; 1400	
; 1401			Show_Cursor();		
	CALL	_Show_Cursor
; 1402			
; 1403			ch = te_gch();
	CALL	_te_gch
	LD	(IX+-1),A
; 1404			
; 1405			if ((' ' <= ch) && (ch <= '~'))
	CP	A,32
	JP	M,L_344
	LD	A,126
	CP	A,(IX+-1)
	JP	M,L__258
	JP	PE,L_344
	JR	L__259
L__258:
	JP	PO,L_344
L__259:
; 1406				do_chr(ch);
	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	CALL	_do_chr
	POP	BC
; 1407			else
	JR	L_346
L_344:
; 1408				switch (ch)
	LD	A,(IX+-1)
	SEXT	HL
	LD	L,(IX+-1)
	LD	BC,HL
L__243:
	LD	DE,1
	OR	A,A
	SBC	HL,DE
	JR	C,L_346
	LD	HL,20
	OR	A,A
	SBC	HL,BC
	JR	C,L_346
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	OR	A,A
	SBC	HL,BC
	LD	BC,L__242-3
	ADD	HL,BC
	LD	HL,(HL)
	JP	(HL)
L__242:
	DW24	L_334	

	DW24	L_315	

	DW24	L_316	

	DW24	L_317	

	DW24	L_318	

	DW24	L_319	

	DW24	L_346	

	DW24	L_320	

	DW24	L_321	

	DW24	L_346	

	DW24	L_322	

	DW24	L_323	

	DW24	L_324	

	DW24	L_325	

	DW24	L_346	

	DW24	L_346	

	DW24	L_329	

	DW24	L_326	

	DW24	L_327	

	DW24	L_328	

; 1409				{
; 1410					case		2: do_enhanced_ret(); break;		/* Control-B. Break Line.             */
L_315:
	CALL	_do_enhanced_ret
	JR	L_346
; 1411					case		3: do_pup(); break;					/* PageUp.             				  */
L_316:
	CALL	_do_pup
	JR	L_346
; 1412					case		4: do_dch(); break;					/* Delete character, Canc Key.		  */
L_317:
	CALL	_do_dch
	JR	L_346
; 1413					case		5: do_bot(1); break;				/* Control-E. End of text.      	  */
L_318:
	LD	BC,1
	PUSH	BC
	CALL	_do_bot
	POP	BC
	JR	L_346
; 1414					case 		6: do_pdw(); break;					/* PageDown.           				  */
L_319:
	CALL	_do_pdw
	JR	L_346
; 1415					case 		8: do_del(); break;					/* Delete character, Backspace Key.	  */
L_320:
	CALL	_do_del
	JR	L_346
; 1416					case		9: do_tab(); break;					/* Tab.           				  	  */
L_321:
	CALL	_do_tab
	JR	L_346
; 1417					case		11: do_dln(); break;				/* Control-K. Delete line.      	  */
L_322:
	CALL	_do_dln
	JR	L_346
; 1418					case		12: do_iln(); break;				/* Control-L. Insert line.      	  */
L_323:
	CALL	_do_iln
	JR	L_346
; 1419					case 		13: do_ret(); break;				/* Return (No new line)				  */
L_324:
	CALL	_do_ret
	JR	L_346
; 1420					case		14: do_red(); break;				/* Control-N. Redraw screen.    	  */
L_325:
	CALL	_do_red
	JR	L_346
; 1421					case		18: reload_file(); break;			/* Control-R. Reload file.	     	  */
L_326:
	CALL	_reload_file
	JR	L_346
; 1422					case		19: save_file(); break;				/* Control-S. Save file.	     	  */
L_327:
	CALL	_save_file
	JR	L_346
; 1423					case		20: do_top(); break;				/* Control-T. Top of file.      	  */
L_328:
	CALL	_do_top
	JR	L_346
; 1424					
; 1425					case		17: msg_window("Quit to PROSE ?", "Y/n");	/* Control-Q. Exit.      	  */
L_329:
	LD	BC,L__246
	PUSH	BC
	LD	BC,L__247
	PUSH	BC
	CALL	_msg_window
	POP	BC
	POP	BC
; 1426									getch();
	CALL	_getch
; 1427									close_msg_window();
	CALL	_close_msg_window
; 1428									
; 1429									if ((Ascii != 89) && (Ascii != 121))
	LD	A,(_Ascii)
	CP	A,89
	JR	Z,L_332
	LD	A,(_Ascii)
	CP	A,121
	JR	NZ,L_346
	JR	L_332
; 1430									 continue;
; 1431									
; 1432									goto quit;
; 1433						
; 1434					case		1:
L_334:
; 1435						switch (Scancode)
	LD	A,(_Scancode)
	UEXT	HL
	LD	L,A
	LD	BC,HL
L__252:
	LD	DE,112
	OR	A,A
	SBC	HL,DE
	JR	C,L__253
	LD	HL,117
	OR	A,A
	SBC	HL,BC
	JR	C,L_346
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	OR	A,A
	SBC	HL,BC
	LD	DE,L__251-336
	ADD	HL,DE
	LD	HL,(HL)
	JP	(HL)
L__251:
	DW24	L_341	

	DW24	L_346	

	DW24	L_338	

	DW24	L_346	

	DW24	L_335	

	DW24	L_337	

L__253:
	LD	DE,105
	LD	HL,BC
	OR	A,A
	SBC	HL,DE
	JR	C,L_346
	LD	HL,108
	OR	A,A
	SBC	HL,BC
	JR	C,L_346
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	OR	A,A
	SBC	HL,BC
	LD	BC,L__250-315
	ADD	HL,BC
	LD	HL,(HL)
	JP	(HL)
L__250:
	DW24	L_340	

	DW24	L_346	

	DW24	L_336	

	DW24	L_339	

; 1436						{
; 1437							case	0x74: do_crt(); break;			/* Cursor right.					  */
L_335:
	CALL	_do_crt
	JR	L_346
; 1438							case	0x6B: do_clf(); break;			/* Cursor left.					  	  */
L_336:
	CALL	_do_clf
	JR	L_346
; 1439							case	0x75: do_cup(); break;			/* Cursor up.					  	  */
L_337:
	CALL	_do_cup
	JR	L_346
; 1440							case	0x72: do_cdw(); break;			/* Cursor down.					  	  */
L_338:
	CALL	_do_cdw
	JR	L_346
; 1441							case	0x6C: do_home(); break;			/* Home key.					  	  */
L_339:
	CALL	_do_home
	JR	L_346
; 1442							case	0x69: do_endline(); break;		/* End key.					  	  	  */
L_340:
	CALL	_do_endline
	JR	L_346
; 1443							case	0x70: do_ins(); break;			/* Ins key.           				  */
L_341:
	CALL	_do_ins
	JR	L_346
L_332:
; 1444						}
; 1445						break;
; 1446				}
; 1447		}
; 1448		
; 1449		quit:;
; 1450	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _edit ***************************
;Name                         Addr/Register   Size   Type
;_do_ins                             IMPORT  -----   function
;_do_endline                         IMPORT  -----   function
;_do_home                            IMPORT  -----   function
;_do_cdw                             IMPORT  -----   function
;_do_cup                             IMPORT  -----   function
;_do_clf                             IMPORT  -----   function
;_do_crt                             IMPORT  -----   function
;_Scancode                           STATIC      1   variable
;_Ascii                              STATIC      1   variable
;_close_msg_window                   IMPORT  -----   function
;_getch                              IMPORT  -----   function
;_msg_window                         IMPORT  -----   function
;_do_top                             IMPORT  -----   function
;_save_file                          IMPORT  -----   function
;_reload_file                        IMPORT  -----   function
;_do_red                             IMPORT  -----   function
;_do_ret                             IMPORT  -----   function
;_do_iln                             IMPORT  -----   function
;_do_dln                             IMPORT  -----   function
;_do_tab                             IMPORT  -----   function
;_do_del                             IMPORT  -----   function
;_do_pdw                             IMPORT  -----   function
;_do_bot                             IMPORT  -----   function
;_do_dch                             IMPORT  -----   function
;_do_pup                             IMPORT  -----   function
;_do_enhanced_ret                    IMPORT  -----   function
;_do_chr                             IMPORT  -----   function
;_te_gch                             IMPORT  -----   function
;_Show_Cursor                        IMPORT  -----   function
;_te_mov                             IMPORT  -----   function
;_Show_Cursor_Position               IMPORT  -----   function
;_sc_upd                             IMPORT  -----   function
;_ShowInsertMode                     IMPORT  -----   function
;_sc_fup                             IMPORT  -----   function
;_paintall                           IMPORT  -----   function
;_p_curr                             STATIC      3   variable
;_p_root                             STATIC      3   variable
;_InsertMode                         STATIC      1   variable
;_cur_char                           STATIC      3   variable
;_cur_line                           STATIC      3   variable
;_cur_col                            STATIC      3   variable
;_cur_row                            STATIC      3   variable
;ch                                    IX-1      1   variable


; Stack Frame Size: 7 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__246:
	DB	"Y/n"
	DB	0
L__247:
	DB	"Quit to PROSE ?"
	DB	0
	SEGMENT CODE
; 1451	
; 1452	/* Draw on screen the cursor position */
; 1453	void Show_Cursor_Position(void)
; 1454	{
_Show_Cursor_Position:
; 1455		Enable_Back_Color();
	CALL	_Enable_Back_Color
; 1456		
; 1457		uitoa(cur_line, convBuf);
	LD	BC,_convBuf
	PUSH	BC
	LD	BC,(_cur_line)
	PUSH	BC
	CALL	_uitoa
	POP	BC
	POP	BC
; 1458		
; 1459		gotoxy(5, 51);
	LD	BC,51
	PUSH	BC
	LD	BC,5
	PUSH	BC
	CALL	_gotoxy
	POP	BC
	POP	BC
; 1460		
; 1461		print("      ");
	LD	BC,L__261
	PUSH	BC
	CALL	_print
	POP	BC
; 1462		
; 1463		gotoxy(5, 51);
	LD	BC,51
	PUSH	BC
	LD	BC,5
	PUSH	BC
	CALL	_gotoxy
	POP	BC
	POP	BC
; 1464		
; 1465		print(convBuf);	
	LD	BC,_convBuf
	PUSH	BC
	CALL	_print
	POP	BC
; 1466		
; 1467		uitoa(cur_col + 1, convBuf);
	LD	BC,_convBuf
	PUSH	BC
	LD	BC,(_cur_col)
	INC	BC
	PUSH	BC
	CALL	_uitoa
	POP	BC
	POP	BC
; 1468		
; 1469		gotoxy(18, 51);
	LD	BC,51
	PUSH	BC
	LD	BC,18
	PUSH	BC
	CALL	_gotoxy
	POP	BC
	POP	BC
; 1470		
; 1471		print("         ");
	LD	BC,L__262
	PUSH	BC
	CALL	_print
	POP	BC
; 1472		
; 1473		gotoxy(18, 51);
	LD	BC,51
	PUSH	BC
	LD	BC,18
	PUSH	BC
	CALL	_gotoxy
	POP	BC
	POP	BC
; 1474		
; 1475		print(convBuf);	
	LD	BC,_convBuf
	PUSH	BC
	CALL	_print
	POP	BC
; 1476		
; 1477		Disable_Back_Color();
	CALL	_Disable_Back_Color
; 1478	}
	RET	


;**************************** _Show_Cursor_Position ***************************
;Name                         Addr/Register   Size   Type
;_Disable_Back_Color                 IMPORT  -----   function
;_cur_col                            STATIC      3   variable
;_print                              IMPORT  -----   function
;_gotoxy                             IMPORT  -----   function
;_cur_line                           STATIC      3   variable
;_convBuf                            STATIC      5   variable
;_uitoa                              IMPORT  -----   function
;_Enable_Back_Color                  IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__261:
	DB	"      "
	DB	0
L__262:
	DB	"         "
	DB	0
	SEGMENT CODE
; 1479	
; 1480	/* Return 1 if the filename passed as parameter exists */
; 1481	char FileExists(void)
; 1482	{
_FileExists:
	LD	HL,-1
	CALL	__frameset
; 1483		char ret;
; 1484		
; 1485		ret = 0;
	LD	(IX+-1),0
; 1486		
; 1487		asm ("push ix");
push ix
; 1488		asm ("ld hl, (_K_xHL)");
ld hl, (_K_xHL)
; 1489		asm ("ld a, kr_find_file");
ld a, kr_find_file
; 1490		asm ("call.lil prose_kernal");
call.lil prose_kernal
; 1491		asm ("pop ix");	
pop ix
; 1492		asm ("jr nz, FindError");
jr nz, FindError
; 1493		
; 1494		ret = 1;
	LD	(IX+-1),1
; 1495		
; 1496		asm ("FindError:");
FindError:
; 1497		
; 1498		return ret;
	LD	A,(IX+-1)
; 1499	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _FileExists ***************************
;Name                         Addr/Register   Size   Type
;ret                                   IX-1      1   variable


; Stack Frame Size: 7 (bytes)
;       Spill Code: 0 (instruction)


; 1500	
; 1501	/* Load file into Video Ram B, after build the text list */
; 1502	void load_file(void)
; 1503	{
_load_file:
	LD	HL,-8
	CALL	__frameset
; 1504		register unsigned int i;
; 1505		char pos = 0, len;
	LD	(IX+-1),0
; 1506		
; 1507		msg_window("Loading file", "Please wait...");
	LD	BC,L__265
	PUSH	BC
	LD	BC,L__266
	PUSH	BC
	CALL	_msg_window
	POP	BC
	POP	BC
; 1508		
; 1509		asm ("push ix");
push ix
; 1510		asm ("ld hl, (_K_xHL)");
ld hl, (_K_xHL)
; 1511		asm ("ld a, kr_find_file");
ld a, kr_find_file
; 1512		asm ("call.lil prose_kernal");
call.lil prose_kernal
; 1513		asm ("pop ix");	
pop ix
; 1514		asm ("jr nz, LoadError");
jr nz, LoadError
; 1515		asm ("ld (_filesize), de");
ld (_filesize), de
; 1516		
; 1517		asm ("push ix");
push ix
; 1518		asm ("ld de, (_filesize)");
ld de, (_filesize)
; 1519		asm ("ld a, kr_set_load_length");
ld a, kr_set_load_length
; 1520		asm ("call.lil prose_kernal");
call.lil prose_kernal
; 1521		asm ("pop ix");
pop ix
; 1522		
; 1523		asm ("push ix");
push ix
; 1524		asm ("ld hl, (_BufferFile)");
ld hl, (_BufferFile)
; 1525		asm ("ld a, kr_read_file");
ld a, kr_read_file
; 1526		asm ("call.lil prose_kernal");
call.lil prose_kernal
; 1527		asm ("jr nz, LoadError");
jr nz, LoadError
; 1528		asm ("pop ix");
pop ix
; 1529		
; 1530		memset(linbuf, 0, sizeof(linbuf));
	LD	BC,90
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_linbuf
	PUSH	BC
	CALL	_memset
; 1531		
; 1532		linbuf[0] = EOS;
	XOR	A,A
	LD	(_linbuf),A
; 1533		i = 0;	
	LD	DE,0
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-4),DE
; 1534		
; 1535		while (i <= filesize)
	JR	L_364
L_365:
; 1536		{
; 1537			if (pos < MAXLNLEN - 1)
	LD	A,(IX+-1)
	CP	A,79
	JP	P,L__276
	JP	PE,L_363
	JR	L__277
L__276:
	JP	PO,L_363
L__277:
; 1538			{
; 1539				linbuf[pos] = BufferFile[i];
	LD	A,(IX+-1)
	SEXT	HL
	LD	L,(IX+-1)
	LD	BC,_linbuf
	ADD	HL,BC
	LD	(IX+-8),HL
	LD	BC,(IX+-4)
	LD	HL,(_BufferFile)
	ADD	HL,BC
	LD	A,(HL)
	LD	HL,(IX+-8)
	LD	(HL),A
; 1540				
; 1541				if ((linbuf[pos] == EOL) || (i == filesize))
	LD	HL,(IX+-8)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	OR	A,A
	LD	BC,10
	SBC	HL,BC
	JR	Z,L_356
	LD	BC,(IX+-4)
	LD	HL,(_filesize)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_357
L_356:
; 1542				{
; 1543					len = strlen(linbuf);
	LD	BC,_linbuf
	PUSH	BC
	CALL	_strlen
	POP	BC
	LD	(IX+-5),L
; 1544					
; 1545					if (linbuf[pos] == EOL)
	LD	A,(IX+-1)
	SEXT	HL
	LD	L,(IX+-1)
	LD	BC,_linbuf
	ADD	HL,BC
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	OR	A,A
	LD	BC,10
	SBC	HL,BC
	JR	NZ,L_353
; 1546						linbuf[len - 1] = EOS;
	LD	A,(IX+-5)
	SEXT	HL
	LD	L,(IX+-5)
	DEC	HL
	LD	BC,_linbuf
	ADD	HL,BC
	LD	(HL),0
; 1547					else
	JR	L_354
L_353:
; 1548						linbuf[pos + 1] = EOS;				
	LD	A,(IX+-1)
	SEXT	HL
	LD	L,(IX+-1)
	INC	HL
	LD	BC,_linbuf
	ADD	HL,BC
	LD	(HL),0
L_354:
; 1549					
; 1550					purify(linbuf);
	PUSH	BC
	CALL	_purify
	POP	BC
; 1551						
; 1552					tx_ins(p_root, linbuf);
	LD	BC,_linbuf
	PUSH	BC
	LD	BC,(_p_root)
	PUSH	BC
	CALL	_tx_ins
	POP	BC
	POP	BC
; 1553				
; 1554					pos = 0;
	LD	(IX+-1),0
; 1555					memset(linbuf, 0, sizeof(linbuf));
	LD	BC,90
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_linbuf
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
; 1556				}
; 1557				else
	JR	L_359
L_357:
; 1558					pos++;
	INC	(IX+-1)
L_359:
; 1559				
; 1560				i++;
	LD	BC,(IX+-4)
	INC	BC
	LD	(IX+-4),BC
; 1561			}
; 1562			else
	JR	L_364
L_363:
; 1563			{
; 1564				purify(linbuf);
	LD	BC,_linbuf
	PUSH	BC
	CALL	_purify
	POP	BC
; 1565				
; 1566				tx_ins(p_root, linbuf);
	LD	BC,_linbuf
	PUSH	BC
	LD	BC,(_p_root)
	PUSH	BC
	CALL	_tx_ins
	POP	BC
	POP	BC
; 1567				
; 1568				pos = 0;
	LD	(IX+-1),0
; 1569				memset(linbuf, 0, sizeof(linbuf));
	LD	BC,90
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_linbuf
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
; 1570				
; 1571				if ((BufferFile[i] == 0x0D) && (BufferFile[i + 1] == 0x0A))
	LD	BC,(IX+-4)
	LD	HL,(_BufferFile)
	ADD	HL,BC
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	OR	A,A
	LD	BC,13
	SBC	HL,BC
	JR	NZ,L_364
	LD	BC,(IX+-4)
	INC	BC
	LD	HL,(_BufferFile)
	ADD	HL,BC
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	OR	A,A
	LD	BC,10
	SBC	HL,BC
	JR	NZ,L_364
; 1572					i += 2;
	LD	IY,(IX+-4)
	LEA	IY,IY+2
	LD	(IX+-4),IY
; 1573			}
; 1574		}	
L_364:
	LD	BC,(IX+-4)
	LD	HL,(_filesize)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_365
; 1575		
; 1576		asm ("jp f_end");
jp f_end
; 1577		
; 1578		asm ("LoadError:");
LoadError:
; 1579		msg_window("Loading file", "File error!");
	LD	BC,L__274
	PUSH	BC
	LD	BC,L__275
	PUSH	BC
	CALL	_msg_window
	POP	BC
	POP	BC
; 1580		getch();	
	CALL	_getch
; 1581		
; 1582		asm ("f_end:");
f_end:
; 1583		
; 1584		close_msg_window();
	CALL	_close_msg_window
; 1585	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _load_file ***************************
;Name                         Addr/Register   Size   Type
;_close_msg_window                   IMPORT  -----   function
;_getch                              IMPORT  -----   function
;_p_root                             STATIC      3   variable
;_tx_ins                             IMPORT  -----   function
;_purify                             IMPORT  -----   function
;_strlen                             IMPORT  -----   function
;_filesize                           STATIC      3   variable
;_BufferFile                         STATIC      3   variable
;_linbuf                             STATIC     90   variable
;_memset                             IMPORT  -----   function
;_msg_window                         IMPORT  -----   function
;len                                   IX-5      1   variable
;i                                     IX-4      3   variable
;pos                                   IX-1      1   variable


; Stack Frame Size: 14 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__265:
	DB	"Please wait..."
	DB	0
L__266:
	DB	"Loading file"
	DB	0
L__274:
	DB	"File error!"
	DB	0
L__275:
	DB	"Loading file"
	DB	0
	SEGMENT CODE
; 1586	
; 1587	/* From text list create the file into Video Ram B, after save it */
; 1588	void save_file(void)
; 1589	{
_save_file:
	LD	HL,-6
	CALL	__frameset
; 1590		p_line_t p_line = p_root->p_next;
	LD	IY,(_p_root)
	LD	BC,(IY+3)
	LD	(IX+-3),BC
; 1591		int slen;	
; 1592		
; 1593		
; 1594		if (UseFile == 0)
	LD	A,(_UseFile)
	OR	A,A
	JR	NZ,L_369
; 1595		{
; 1596			asm ("ld hl, (_NonameFile)");
ld hl, (_NonameFile)
; 1597			asm ("ld (_K_xHL), hl");
ld (_K_xHL), hl
; 1598			
; 1599			msg_window("Please wait, saving", NonameFile);
	LD	BC,(_NonameFile)
	PUSH	BC
	LD	BC,L__280
	PUSH	BC
	CALL	_msg_window
	POP	BC
	POP	BC
; 1600		}
; 1601		else
	JR	L_370
L_369:
; 1602			msg_window("Saving file", "Please wait...");
	LD	BC,L__281
	PUSH	BC
	LD	BC,L__282
	PUSH	BC
	CALL	_msg_window
	POP	BC
	POP	BC
L_370:
; 1603		
; 1604		asm ("push ix");
push ix
; 1605		asm ("ld hl, (_K_xHL)");
ld hl, (_K_xHL)
; 1606		asm ("ld a, kr_erase_file");
ld a, kr_erase_file
; 1607		asm ("call.lil prose_kernal");
call.lil prose_kernal
; 1608		asm ("pop ix");	
pop ix
; 1609		
; 1610		asm ("push ix");
push ix
; 1611		asm ("ld hl, (_K_xHL)");
ld hl, (_K_xHL)
; 1612		asm ("ld a, kr_create_file");
ld a, kr_create_file
; 1613		asm ("call.lil prose_kernal");
call.lil prose_kernal
; 1614		asm ("pop ix");
pop ix
; 1615		asm ("jr nz, SaveError");	
jr nz, SaveError
; 1616		
; 1617		filesize = 0;	
	LD	BC,0
	LD	(_filesize),BC
; 1618		
; 1619		while (p_line != p_root)
	JR	L_373
L_374:
; 1620		{
; 1621			slen = strlen(p_line->p_data);
	LD	IY,(IX+-3)
	LD	BC,(IY+6)
	PUSH	BC
	CALL	_strlen
	POP	BC
	LD	(IX+-6),HL
; 1622			
; 1623			if (slen > 0)
	LD	BC,HL
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	JP	P,L_372
; 1624				memmove(BufferFile + filesize, p_line->p_data, slen);
	LD	BC,(IX+-6)
	PUSH	BC
	LD	IY,(IX+-3)
	LD	BC,(IY+6)
	PUSH	BC
	LD	BC,(_filesize)
	LD	HL,(_BufferFile)
	ADD	HL,BC
	PUSH	HL
	CALL	_memmove
	POP	BC
	POP	BC
	POP	BC
L_372:
; 1625			
; 1626			filesize += slen;
	LD	BC,(IX+-6)
	LD	HL,(_filesize)
	ADD	HL,BC
	LD	(_filesize),HL
; 1627			
; 1628			BufferFile[filesize] = 0x0D;
	LD	BC,(_filesize)
	LD	HL,(_BufferFile)
	ADD	HL,BC
	LD	(HL),13
; 1629			BufferFile[filesize + 1] = 0x0A;
	LD	BC,(_filesize)
	INC	BC
	LD	HL,(_BufferFile)
	ADD	HL,BC
	LD	(HL),10
; 1630			
; 1631			filesize += 2;
	LD	IY,(_filesize)
	LEA	BC,IY+2
	LD	(_filesize),BC
; 1632			
; 1633			p_line = p_line->p_next;
	LD	IY,(IX+-3)
	LD	BC,(IY+3)
	LD	(IX+-3),BC
; 1634		}
L_373:
	LD	BC,(IX+-3)
	LD	HL,(_p_root)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_374
; 1635		
; 1636		filesize -= 2;
	LD	IY,(_filesize)
	LEA	BC,IY+-2
	LD	(_filesize),BC
; 1637		
; 1638		asm ("push ix");
push ix
; 1639		asm ("ld hl, (_K_xHL)");
ld hl, (_K_xHL)
; 1640		asm ("ld de, (_BufferFile)");
ld de, (_BufferFile)
; 1641		asm ("ld bc, (_filesize)");
ld bc, (_filesize)
; 1642		asm ("ld a, kr_write_file");
ld a, kr_write_file
; 1643		asm ("call.lil prose_kernal");
call.lil prose_kernal
; 1644		asm ("pop ix");	
pop ix
; 1645		
; 1646		asm ("jp s_end");
jp s_end
; 1647		
; 1648		asm ("SaveError:");
SaveError:
; 1649		msg_window("Saving file", "File error!");
	LD	BC,L__285
	PUSH	BC
	LD	BC,L__286
	PUSH	BC
	CALL	_msg_window
	POP	BC
	POP	BC
; 1650		getch();	
	CALL	_getch
; 1651		
; 1652		asm ("s_end:");
s_end:
; 1653		close_msg_window();
	CALL	_close_msg_window
; 1654	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _save_file ***************************
;Name                         Addr/Register   Size   Type
;_close_msg_window                   IMPORT  -----   function
;_getch                              IMPORT  -----   function
;_BufferFile                         STATIC      3   variable
;_memmove                            IMPORT  -----   function
;_strlen                             IMPORT  -----   function
;_filesize                           STATIC      3   variable
;_NonameFile                         STATIC      3   variable
;_msg_window                         IMPORT  -----   function
;_UseFile                            STATIC      1   variable
;_p_root                             STATIC      3   variable
;slen                                  IX-6      3   variable
;p_line                                IX-3      3   variable


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__280:
	DB	"Please wait, saving"
	DB	0
L__281:
	DB	"Please wait..."
	DB	0
L__282:
	DB	"Saving file"
	DB	0
L__285:
	DB	"File error!"
	DB	0
L__286:
	DB	"Saving file"
	DB	0
	SEGMENT CODE
; 1655	
; 1656	/* Reload the file if exist */
; 1657	void reload_file(void)
; 1658	{
_reload_file:
; 1659		if (UseFile == 1)
	LD	A,(_UseFile)
	CP	A,1
	JR	NZ,L_382
; 1660			if (FileExists() == 1)
	CALL	_FileExists
	LD	B,A
	SEXT	HL
	LD	L,B
	OR	A,A
	LD	BC,1
	SBC	HL,BC
	JR	NZ,L_382
; 1661			{
; 1662				msg_window("Reload file ?", "Y/n");
	LD	BC,L__290
	PUSH	BC
	LD	BC,L__291
	PUSH	BC
	CALL	_msg_window
	POP	BC
	POP	BC
; 1663				getch();
	CALL	_getch
; 1664				close_msg_window();
	CALL	_close_msg_window
; 1665				
; 1666				if ((Ascii != 89) && (Ascii != 121))
	LD	A,(_Ascii)
	CP	A,89
	JR	Z,L_379
	LD	A,(_Ascii)
	CP	A,121
	JR	NZ,L_382
; 1667					return;
L_379:
; 1668				
; 1669				sc_fin();
	CALL	_sc_fin
; 1670				te_fin();
	CALL	_te_fin
; 1671				
; 1672				memset(BufferFile, 0, 1024 * 512);
	LD	BC,524288
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,(_BufferFile)
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
; 1673				
; 1674				te_ini();
	CALL	_te_ini
; 1675				sc_ini();
	CALL	_sc_ini
; 1676				tx_ini();			
	CALL	_tx_ini
; 1677				
; 1678				load_file();
	CALL	_load_file
; 1679				
; 1680				cur_row = 0;
	LD	BC,0
	LD	(_cur_row),BC
; 1681				cur_col = 0;
	LD	(_cur_col),BC
; 1682				cur_line = 1;
	LD	BC,1
	LD	(_cur_line),BC
; 1683				cur_char = 1;
	LD	(_cur_char),BC
; 1684				p_curr = p_root->p_next;	
	LD	IY,(_p_root)
	LD	BC,(IY+3)
	LD	(_p_curr),BC
; 1685		
; 1686				paintall();
	CALL	_paintall
; 1687		
; 1688				sc_fup();
	CALL	_sc_fup
; 1689			}
; 1690	}
L_382:
	RET	


;**************************** _reload_file ***************************
;Name                         Addr/Register   Size   Type
;_sc_fup                             IMPORT  -----   function
;_paintall                           IMPORT  -----   function
;_p_curr                             STATIC      3   variable
;_p_root                             STATIC      3   variable
;_cur_char                           STATIC      3   variable
;_cur_line                           STATIC      3   variable
;_cur_col                            STATIC      3   variable
;_cur_row                            STATIC      3   variable
;_load_file                          IMPORT  -----   function
;_tx_ini                             IMPORT  -----   function
;_sc_ini                             IMPORT  -----   function
;_te_ini                             IMPORT  -----   function
;_BufferFile                         STATIC      3   variable
;_memset                             IMPORT  -----   function
;_te_fin                             IMPORT  -----   function
;_sc_fin                             IMPORT  -----   function
;_Ascii                              STATIC      1   variable
;_close_msg_window                   IMPORT  -----   function
;_getch                              IMPORT  -----   function
;_msg_window                         IMPORT  -----   function
;_FileExists                         IMPORT  -----   function
;_UseFile                            STATIC      1   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__290:
	DB	"Y/n"
	DB	0
L__291:
	DB	"Reload file ?"
	DB	0
	SEGMENT CODE
; 1691	
; 1692	/* Draw on screen the message box width 2 lines of text */
; 1693	void msg_window(char *msg1, char *msg2)
; 1694	{
_msg_window:
	LD	HL,-4
	CALL	__frameset
; 1695		char r, c, len, posx;
; 1696	
; 1697		memset(backbuffer, 0, sizeof(backbuffer));
	LD	BC,320
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,_backbuffer
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-2),0
; 1698		
; 1699		for (r = 0; r < 4; r++)
	JR	L_390
L_388:
	LD	(IX+-1),0
; 1700			for (c = 0; c < SCNCOLS; c++)
	JR	L_387
L_385:
; 1701				backbuffer[r][c] = scn_phys[r + 23][c];
	LD	A,(IX+-2)
	SEXT	HL
	LD	L,(IX+-2)
	LD	IY,HL
	LEA	BC,IY+23
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	A,(IX+-1)
	LD	BC,_scn_phys
	ADD	HL,BC
	LD	BC,HL
	SEXT	HL
	LD	L,(IX+-1)
	LD	A,(IX+-2)
	ADD	HL,BC
	LD	IY,HL
	SEXT	HL
	LD	L,(IX+-2)
	LD	A,(IX+-1)
	LD	BC,HL
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_backbuffer
	ADD	HL,BC
	LD	BC,HL
	SEXT	HL
	LD	L,(IX+-1)
	LD	A,(IY)
	ADD	HL,BC
	LD	(HL),A
	INC	(IX+-1)
L_387:
	LD	A,(IX+-1)
	CP	A,80
	JP	M,L__311
	JP	PE,L_385
	JR	L__312
L__311:
	JP	PO,L_385
L__312:
	INC	(IX+-2)
L_390:
	LD	A,(IX+-2)
	CP	A,4
	JP	M,L__313
	JP	PE,L_388
	JR	L__314
L__313:
	JP	PO,L_388
L__314:
; 1702		
; 1703		Enable_Back_Color();
	CALL	_Enable_Back_Color
; 1704		
; 1705		gotoxy(0, 23);
	LD	BC,23
	PUSH	BC
	LD	BC,0
	PUSH	BC
	CALL	_gotoxy
	POP	BC
	POP	BC
; 1706			
; 1707		len = strlen(msg1);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_strlen
	POP	BC
	LD	(IX+-3),L
; 1708		posx = 40 - (len / 2);
	LD	A,(IX+-3)
	SEXT	HL
	LD	L,(IX+-3)
	LD	BC,2
	CALL	__idivs
	LD	A,40
	SUB	A,L
	LD	(IX+-4),A
; 1709		
; 1710		print("+==================================]PROTED[====================================+");
	LD	BC,L__297
	PUSH	BC
	CALL	_print
	POP	BC
; 1711		print("|");
	LD	BC,L__298
	PUSH	BC
	CALL	_print
	POP	BC
	LD	(IX+-1),1
; 1712		
; 1713		for (c = 1; c < posx - 1; c++)
	JR	L_395
L_393:
; 1714			print(" ");
	LD	BC,L__299
	PUSH	BC
	CALL	_print
	POP	BC
	INC	(IX+-1)
L_395:
	LD	A,(IX+-4)
	SEXT	HL
	LD	L,(IX+-4)
	LD	BC,HL
	DEC	BC
	LD	A,(IX+-1)
	SEXT	HL
	LD	L,(IX+-1)
	OR	A,A
	SBC	HL,BC
	JP	M,L__315
	JP	PE,L_393
	JR	L__316
L__315:
	JP	PO,L_393
L__316:
; 1715		
; 1716		print(msg1);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_print
	POP	BC
	LD	A,(IX+-1)
	ADD	A,(IX+-3)
	LD	(IX+-2),A
; 1717		
; 1718		for (r = c + len; r < SCNCOLS - 1; r++)
	JR	L_400
L_398:
; 1719			print(" ");
	LD	BC,L__301
	PUSH	BC
	CALL	_print
	POP	BC
	INC	(IX+-2)
L_400:
	LD	A,(IX+-2)
	CP	A,79
	JP	M,L__317
	JP	PE,L_398
	JR	L__318
L__317:
	JP	PO,L_398
L__318:
; 1720		
; 1721		print("|");
	LD	BC,L__303
	PUSH	BC
	CALL	_print
	POP	BC
; 1722		
; 1723		len = strlen(msg2);
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_strlen
	POP	BC
	LD	(IX+-3),L
; 1724		posx = 40 - (len / 2);
	LD	A,(IX+-3)
	SEXT	HL
	LD	L,(IX+-3)
	LD	BC,2
	CALL	__idivs
	LD	A,40
	SUB	A,L
	LD	(IX+-4),A
; 1725		print("|");
	LD	BC,L__304
	PUSH	BC
	CALL	_print
	POP	BC
	LD	(IX+-1),1
; 1726		
; 1727		for (c = 1; c < posx - 1; c++)
	JR	L_405
L_403:
; 1728			print(" ");
	LD	BC,L__305
	PUSH	BC
	CALL	_print
	POP	BC
	INC	(IX+-1)
L_405:
	LD	A,(IX+-4)
	SEXT	HL
	LD	L,(IX+-4)
	LD	BC,HL
	DEC	BC
	LD	A,(IX+-1)
	SEXT	HL
	LD	L,(IX+-1)
	OR	A,A
	SBC	HL,BC
	JP	M,L__319
	JP	PE,L_403
	JR	L__320
L__319:
	JP	PO,L_403
L__320:
; 1729		
; 1730		print(msg2);
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_print
	POP	BC
	LD	A,(IX+-1)
	ADD	A,(IX+-3)
	LD	(IX+-2),A
; 1731		
; 1732		for (r = c + len; r < SCNCOLS - 1; r++)
	JR	L_410
L_408:
; 1733			print(" ");
	LD	BC,L__307
	PUSH	BC
	CALL	_print
	POP	BC
	INC	(IX+-2)
L_410:
	LD	A,(IX+-2)
	CP	A,79
	JP	M,L__321
	JP	PE,L_408
	JR	L__322
L__321:
	JP	PO,L_408
L__322:
; 1734		
; 1735		print("|");
	LD	BC,L__309
	PUSH	BC
	CALL	_print
	POP	BC
; 1736		
; 1737		print("+==============================================================================+");
	LD	BC,L__310
	PUSH	BC
	CALL	_print
	POP	BC
; 1738		
; 1739		Disable_Back_Color();
	CALL	_Disable_Back_Color
; 1740	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _msg_window ***************************
;Name                         Addr/Register   Size   Type
;_Disable_Back_Color                 IMPORT  -----   function
;_print                              IMPORT  -----   function
;_strlen                             IMPORT  -----   function
;_gotoxy                             IMPORT  -----   function
;_Enable_Back_Color                  IMPORT  -----   function
;_scn_phys                           STATIC   4000   variable
;_backbuffer                         STATIC    320   variable
;_memset                             IMPORT  -----   function
;posx                                  IX-4      1   variable
;len                                   IX-3      1   variable
;r                                     IX-2      1   variable
;c                                     IX-1      1   variable
;msg2                                  IX+9      3   parameter
;msg1                                  IX+6      3   parameter


; Stack Frame Size: 16 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__297:
	DB	"+==================================]PROTED[====================================+"
	DB	0
L__298:
	DB	"|"
	DB	0
L__299:
	DB	" "
	DB	0
L__301:
	DB	" "
	DB	0
L__303:
	DB	"|"
	DB	0
L__304:
	DB	"|"
	DB	0
L__305:
	DB	" "
	DB	0
L__307:
	DB	" "
	DB	0
L__309:
	DB	"|"
	DB	0
L__310:
	DB	"+==============================================================================+"
	DB	0
	SEGMENT CODE
; 1741	
; 1742	/* Close the message box */
; 1743	void close_msg_window(void)
; 1744	{
_close_msg_window:
	LD	HL,-2
	CALL	__frameset
; 1745		register char r, c;
; 1746		
; 1747		Disable_Back_Color();
	CALL	_Disable_Back_Color
	LD	(IX+-1),0
; 1748		
; 1749		for (r = 0; r < 4; r++)
	JR	L_420
L_418:
	LD	(IX+-2),0
; 1750			for (c = 0; c < SCNCOLS; c++)
	JR	L_417
L_415:
; 1751				plot_char(c, r + 23, backbuffer[r][c]);
	LD	A,(IX+-1)
	SEXT	HL
	LD	L,(IX+-1)
	LD	BC,HL
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_backbuffer
	ADD	HL,BC
	LD	BC,HL
	LD	A,(IX+-2)
	SEXT	HL
	LD	L,(IX+-2)
	ADD	HL,BC
	LD	C,(HL)
	LD	B,0
	PUSH	BC
	LD	A,(IX+-1)
	ADD	A,23
	LD	C,A
	PUSH	BC
	LD	C,(IX+-2)
	PUSH	BC
	CALL	_plot_char
	POP	BC
	POP	BC
	POP	BC
	INC	(IX+-2)
L_417:
	LD	A,(IX+-2)
	CP	A,80
	JP	M,L__326
	JP	PE,L_415
	JR	L__327
L__326:
	JP	PO,L_415
L__327:
	INC	(IX+-1)
L_420:
	LD	A,(IX+-1)
	CP	A,4
	JP	M,L__328
	JP	PE,L_418
	JR	L__329
L__328:
	JP	PO,L_418
L__329:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _close_msg_window ***************************
;Name                         Addr/Register   Size   Type
;_backbuffer                         STATIC    320   variable
;_plot_char                          IMPORT  -----   function
;_Disable_Back_Color                 IMPORT  -----   function
;c                                     IX-2      1   variable
;r                                     IX-1      1   variable


; Stack Frame Size: 8 (bytes)
;       Spill Code: 0 (instruction)


	XREF _strlen:ROM
	XREF _memmove:ROM
	XREF _memset:ROM
	XREF _memcmp:ROM
	XREF _strcpy:ROM
	XREF _malloc:ROM
	XREF _free:ROM
	XREF __idivs:ROM
	XREF __idivu:ROM
	XREF __irems:ROM
	XREF __iremu:ROM
	XREF __frameset0:ROM
	XREF __frameset:ROM
	XDEF _close_msg_window
	XDEF _msg_window
	XDEF _reload_file
	XDEF _save_file
	XDEF _load_file
	XDEF _FileExists
	XDEF _Show_Cursor_Position
	XDEF _edit
	XDEF _Disable_Back_Color
	XDEF _Enable_Back_Color
	XDEF _ShowInsertMode
	XDEF _ShowMenu
	XDEF _Show_Cursor
	XDEF _paintrow
	XDEF _paintall
	XDEF _do_ins
	XDEF _do_endline
	XDEF _do_home
	XDEF _do_enhanced_del
	XDEF _do_del
	XDEF _do_dln
	XDEF _do_iln
	XDEF _do_dch
	XDEF _do_chr
	XDEF _do_bot
	XDEF _do_top
	XDEF _do_tab
	XDEF _do_enhanced_ret
	XDEF _do_ret
	XDEF _do_pup
	XDEF _do_pdw
	XDEF _do_crt
	XDEF _do_clf
	XDEF _do_cdw
	XDEF _do_cup
	XDEF _do_red
	XDEF _tx_put
	XDEF _tx_get
	XDEF _tx_del
	XDEF _tx_ins
	XDEF _tx_set
	XDEF _tx_ini
	XDEF _sc_fin
	XDEF _sc_ini
	XDEF _sc_fup
	XDEF _sc_upd
	XDEF _sc_str
	XDEF _sc_chr
	XDEF _sc_crw
	XDEF _sc_clr
	XDEF _te_fin
	XDEF _te_ini
	XDEF _te_clr
	XDEF _te_cln
	XDEF _te_mov
	XDEF _te_str
	XDEF _te_chr
	XDEF _te_gch
	XDEF _te_flu
	XDEF _purify
	XDEF _zap_trail
	XDEF _blankrow
	XDEF _mymalloc
	XDEF _uitoa
	XDEF _as
	XDEF _bomb
	XDEF _get_display_size
	XDEF _get_prose_version
	XDEF _gotoxy
	XDEF _clreol
	XDEF _plot_char
	XDEF _get_cursor_position
	XDEF _print
	XDEF _getch
	XDEF _GetCh
	XDEF _main
	XDEF _convBuf
	XDEF _UseFile
	XDEF _BufferFile
	XDEF _filesize
	XDEF _K_xBC
	XDEF _K_xHL
	XDEF _linbuf
	XDEF _cur_col
	XDEF _cur_row
	XDEF _cur_char
	XDEF _cur_line
	XDEF _numlines
	XDEF _p_curr
	XDEF _p_root
	XDEF _root
	XDEF _backbuffer
	XDEF _scn_phys
	XDEF _scn_virt
	XDEF _tebuflen
	END
