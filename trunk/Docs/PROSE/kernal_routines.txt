PROSE KERNAL ROUTINES (last updated 22-8-2011)
----------------------------------------------

General: 

To call a PROSE kernal routine, load the accumulator with the routine label,
set other registers as appropriate for the routine in question and do an ADL
call to PROSE_KERNAL.

EG: To print a line of text:

	ld hl,message_txt			; string location
	ld a,kr_print_string			; desired kernal routine
	call.lil prose_kernal			; call PROSE kernal routine

This applies to both Z80 mode and ADL mode programs. (When a Z80 mode program
calls the PROSE kernal, location pointer registers have their MSB [23:16] set
to the MBASE register).


* All *DISK* routines set the zero flag on return if the operation was successful.
  If the zero flag is not set, CPU register "A" will contain an error code
  (see list at end of this document)
  
* Other routines set the flags as applicable.

* IX and IY are preserved by all kernal routines, assume all other registers
  are trashed unless otherwise stated.


.-----------.
|ID | LABEL |
'-----------'

00h - "kr_mount_volumes"				
-----------------------

Action: Rescans hardware for storage devices.
Input : E (0= Show device list, 1 = Do not show any text)
Output: None



01h - "kr_get_device_info"				
-------------------------

Action: Returns info about the storage devices
Input : None
Output: HL (location of device info table), DE (location of driver table), B (Device count), A (Currently selected driver)



02h - "kr_check_volume_format"				
-----------------------------

Action: Checks if currently selected volume is formatted to FAT16
Input : None
Output: See error codes



03h - "kr_change_volume"					
-----------------------

Action: Changes selected volume
Input : E (desired volume number) 
Output: See error codes



04h - "kr_get_volume_info"		
-------------------------

Action: Returns info about storage volumes.
Input : None
Output: HL (location of volume mount list), B (volume count), A (currently selected volume)



05h - "kr_format_device"				
-----------------------

Action: Formats a device to FAT16 (no MBR is created and the entire device is treated as one volume, max 2GB)
Input : E (device), HL = location of desired volume label
Output: See error codes



06h - "kr_make_dir"			
------------------

Action: Creates a new directory
Input : HL (location of zero-terminated dir name)
Output: See error codes



07h - "kr_change_dir"			
--------------------

Action: Changes current directory
Input : HL  (pointer to zero-terminated dir name)
Output: See error codes



08h - "kr_parent_dir"				
--------------------

Action: Moves towards the root directory by one place
Input : None
Output: See error codes



09h - "kr_root_dir"			
------------------

Action: Sets the root dir as the current directory
Input : None
Output: None



0ah - "kr_delete_dir"			
--------------------

Action: Removes an (empty) directory
Input : HL  (pointer to zero-terminated dir name)
Output: See error codes



0bh - "kr_find_file"		
-------------------

Action: Opens a file so that data from it may be loaded.
Input : HL (pointer to zero-terminated file name)
Output: If zero flag set: HL (start cluster of file), C:xDE (length of file) Else see error codes



0ch - "kr_set_file_pointer"		
--------------------------

Action: Moves the file pointer to a position within the currently opened file
Input : C:xDE (32 bit file pointer)
Output: None



0dh - "kr_set_load_length"		
-------------------------

Action: Sets the maximum data transfer length for a file read
Input : xDE (24 bit load length)
Output: None



0eh - "kr_read_file"			
-------------------

Action: Reads data from the currently opened file
Input : xHL (load address)
Output: see error codes



0fh - "kr_erase_file"		
--------------------

Action: Deletes a file
Input : HL (location of zero-terminated file name)
Output: See error codes



10h - "kr_rename_file"			
---------------------

Action: Renames a file or directory
Input : input HL (location of original name), DE  (location of new name) - zero terminate both strings.
Output: See error codes



11h - "kr_create_file"			
---------------------

Action: Creates a new file (zero bytes) for writing data to.
Input : HL  (location of zero-terminated file name)
Output: See error codes



12h - "kr_write_file"		
--------------------

Action: Appends data to an existing file
Input : HL (location of zero terminated filename), xDE (source address of data), xBC (length)
Output: See error codes



13h - "kr_get_total_sectors"		
---------------------------

Action: Returns the total capacity (in sectors) of the currently selected volume
Input : None
Output: xDE (sector count)



14h - "kr_dir_list_first_entry"		
------------------------------

Action: Returns the first line of a directory
Input : None
Output: If zero flag set:

          HL     (Location of null terminated filename string)
          C:xDE  (Length of file  - if applicable)
          B      (File flag 0 = File, 1 = Dir)
        
        Else: see error codes



15h - "kr_dir_list_get_entry"		
----------------------------

Action: Returns a line from directory 
Input : None
Output: If zero flag set:

          HL     (Location of null terminated filename string)
          C:xDE  (Length of file  - if applicable)
          B      (File flag 0 = File, 1 = Dir)
        
        Else: see error codes
        
        

16h - "kr_dir_list_next_entry"		
-----------------------------

Action: Returns next line of directory
Input : None
Output: If zero flag set:

          HL     (Location of null terminated filename string)
          C:xDE  (Length of file  - if applicable)
          B      (File flag 0 = File, 1 = Dir)
        
        Else: see error codes



17h - "kr_read_sector"		
---------------------

Action: Reads a sector from the specified device to the target address
Input : xHL (destination address), C:xDE (sector), B (device number)
Output: See error codes



18h - "kr_write_sector"		
----------------------

Action: Writes a sector from specified address to the specified device
Input : xHL (source address), C:xDE (sector), B (device number)
Output: See error codes



19h - "kr_file_sector_list" (** Changed in PROSE v32 **)		
--------------------------------------------------------

Action: Used to obtain a list of the sectors that a file occupies
Input : HL = cluster, E = sector
Output: E  = Next sector offset
        HL = Updated cluster
        BC = Location of variable holding 32 bit sector (LSB)
        [Also see error codes]
        
Notes: First call "kr_find_file" with the filename in HL as normal. On exit, HL will be
equal the first cluster that the file occupies. Clear E (as we're starting at the
first sector of a cluster), and call "kr_file_sector_list". On return E and HL are
updated to the values required for the next time the routine is called and BC points
to the lowest significant byte of the sector address (LBA0). Copy the 4 bytes
from BC to BC+3 to your sector list buffer and loop around, calling "kr_file_sector_list"
for as many sectors as are used by the file (simply subtract 512 from a variable
holding the file size every call until variable is = < 0)



1ah - "kr_get_dir_cluster"		
-------------------------

Action: Reads the cluster location of the current directory
Input : none
Output: DE (current dir's cluster address)



1bh - "kr_set_dir_cluster"		
-------------------------

Action: Sets the current directory cluster location
Input : DE (cluster address to set as current dir)
Output: none



1ch - "kr_get_dir_name"			
----------------------

Action: Returns current directory name
Input : None
Output: xHL (location of directory name ASCII string)
        [See also error codes]



4ch - "kr_get_disk_sector_ptr"
-----------------------------

Action: Returns location of LSB of LBA sector variable and location of sector buffer for external drivers
Input : none
Output: HL = location of LSB of 32-bit sector address variable, DE = location of sector buffer 


=========================================================================================

1dh - "kr_wait_key"			
------------------

Action: Pauses until a key is pressed
Input : None
Output: A = Scancode, B  = ASCII character modified by shift/alt/CRTL if applicable. 0 if not


1eh - "kr_get_key"			
-----------------

Action: Returns any keypresses that are in the buffer (does not wait)
Input : None
Output: If zero flag is set, A = New scancode, B = (ASCII character modified by shift/alt/CTRL
        if applicable. 0 if not)  Else: No new key data is in the buffer


1fh - "kr_get_key_mod_flags"		
---------------------------

Action: Returns the status of the modifier keys
Input : None
Output: A, bit 0 - left shift
               1 - left/right ctrl
               2 - left GUI
               3 - left/right alt
               4 - right shift
               5 - right GUI
               6 - Apps


========================================================================================================================


20h - "kr_serial_receive_header" (** Changed in PROSE v32 **)		
-------------------------------------------------------------

Action: Waits for a file header from serial port
Input : HL (location of zero-terminated filename), E (timeout)
Output: If zero flag set, all OK, xDE returns location of serial file header
        Otherwise A = $83: time out error, $84: memory address out of range, $85 = comms error
                      $86: checksum bad, $87: Incorrect file 



21h - "kr_serial_receive_file"		
-----------------------------

Action: Waits for a serial file transfer following the reception of a header
Input : xHL (load address)
Output: If zero flag is set, all OK. Else: A: $84 = memory address out of range, $85 = comms error, $86 = checksum error



22h - "kr_serial_send_file" (Updated / Fixed in PROSE v32)		
----------------------------------------------------------

Action: Sends a file to the serial port
Input : HL (filename location), xDE = source address, xBC = length 
Output: If zero flag is set, all OK. 
        Else: A: $81 = Save length zero, $84 = memory address out of range, $85 = comms error



23h - "kr_serial_tx_byte"		
------------------------

Action: Sends a single byte to the serial port
Input : E (byte to send)
Output: None



24h - "kr_serial_rx_byte"
------------------------

Action: Waits for a single byte from serial port
Input : E (timeout in seconds)
Output: Zero Flag set if byte received OK, Else operation timed out (A = $83)



=========================================================================================



25h - "kr_print_string"			
----------------------

Action: Writes a string of text to the display at the current cursor position and in the current pen colour
Input : HL (Zero-terminated ASCII string location)
Output: HL = address of the string terminating zero + 1 (BC and DE are preserved)



26h - "kr_clear_screen"			
----------------------

Action: Clears the display window
Input : None
Output: None



27h - "kr_wait_vrt"			
------------------

Action: Waits for the Vertical Retrace flip-flop to become set (last scanline of display)
Input : None
Output: None



28h - "kr_set_cursor_position"		
-----------------------------

Action: Moves the cursor position to a specific place
Input : B (x char coord), C (y char coord)
Output: Zero flag is set if coordinates are within the display window, unset if not.



29h - "kr_plot_char"			
-------------------

Action: Plots a character at a specific location in current pen colour (doesn't affect cursor position)
Input : B (x char coord), C (y char coord), E (ASCII char to plot)
Output: Zero flag is set if coordinates are within the display window, unset if not.



2ah - "kr_set_pen"			
----------------

Action: Changes the current pen colour
Input : E (pen colour) Bits [7:4] = background colour selection, [3:0] = character's pixel colour selection.
Output: None




2bh - "kr_background_colours"		
----------------------------

Action: Changes the palette of 16 colours used by the OS
Input : HL (location of colour data, standard 16 words of "0RGB" format)
Output: None



2ch - "kr_draw_cursor"			
--------------------

Action: Draws the cursor image as defined by the routine "kr_set_cursor_image"
Input : None
Output: None



2dh - "kr_get_pen"			
----------------

Action: Returns the current pen colour
Input : None
Output: A (pen colour) Bits [7:4] = background colour selection, [3:0] = character's pixel colour selection.



2eh - "kr_scroll_up"			
------------------

Action: Scrolls the display up a line
Input : None
Output: None



2fh - "kr_os_display"			
-------------------

Action: Restores the display hardware settings to that used by the OS (useful only if the
        area of VRAM used by PROSE were not overwritten.)
Input : None
Output: None




30h - "kr_get_video_mode" (previously: "kr_get_display_size")		
-------------------------------------------------------------

Action: Returns the OS video mode and size of the OS window (in characters)
Input : None
Output: A = Video Mode, B = Columns, C = Lines




31h - "kr_get_charmap_addr_xy" 		
----------------------------

Action: Returns address of character map and attribute map for a specific coordinate
Input : B = x coord, C = y coord
Output: xHL = OS character map address, xDE = OS attribute map addresss




32h - "kr_get_cursor_position"		
----------------------------

Action: Returns cursor position
Input : None
Output: B (x char coord), C (y char coord)



48h - "kr_set_video_mode"
-------------------------

Action: Sets the Video Mode
Input : E: 0=80x60, 1=80x30, 2=40x60, 3=40x30
Output: ZF set if all OK. Error code 88h if A is out of range.




49h - "kr_set_cursor_image"
---------------------------

Action: Selects which character is to be used for the cursor.
Input : E: ASCII character to use (EG: 05fh = underscore, 07fh = solid block)
Output: None.



4ah - "kr_remove_cursor"
------------------------

Action: Removes the cursor image from the character map (replaces with character
        that was saved by kr_draw_cursor)
Input : None
Output: None



4bh - "kr_char_to_font"
-----------------------

Action: Patches the PROSE font (allows user defined characters)
Input : E = ASCII character to change, HL = address of font data (8 bytes)
Output: None


=========================================================================================


33h - "kr_set_envar"			
-------------------

Input :  HL = variable name pointer, DE = variable data string
Output:  ZF set if OK



34h - "kr_get_envar"			
-------------------

Input :  HL = variable name pointer
Output:  ZF set if name found: DE = variable data string



35h - "kr_delete_envar"			
----------------------

Input :  HL = variable name pointer
Output:  ZF set if OK



36h - "kr_set_mouse_window"		
--------------------------

Action: Sets the constraining dimensions for absolute mouse pointer position
Input : HL (width of window in pixels), DE (height of window in pixels)
Output: None



37h - "kr_get_mouse_position"		
---------------------------

Action: Returns the absolute position of the mouse pointer within the window (and button status)
Input:  None
Output: If zero flag is set: HL = x coord, DE = y coord , A = buttons (bits 2:0)
        If zero Flag is not set mouse is not enabled



38h - "kr_get_mouse_motion"		
-------------------------

Action: Returns the current value of the (wrap around) mouse counters (and button status)
Input : None
Output: If zero flag is set: HL = x counter, DE = y counter, A = buttons (bits 2:0)
        If zero Flag is not set mouse is not enabled



39h - "kr_time_delay"		
-------------------

Action: Pauses (Granularity of 30 microseconds)
Input : DE = 32768Hz ticks to pause. (Max value 65535, IE: 2 seconds)
Output: None



3ah - "kr_compare_strings"	
-------------------------

Action: Compares ASCII strings, ignoring the case.
Input:  xHL, xDE (location of strings) B = count of characters to compare
Output: Zero flag set if strings are the same



3bh - "kr_hex_byte_to_ascii"		
---------------------------

Action: Puts ascii version of hex byte at (xHL) and (xHL+1)
Input : E (byte to convert)
Output: xHL=xHL+2



3ch - "kr_ascii_to_hex_word" 	
----------------------------

Action: Converts ASCII hex characters to 24 bit hexadecimal number
Input:  xHL = location of ASCII string (Note: routine scans for first non-space character)
Output: xDE = result, Zero Flag set if all OK, else A = $81: No ASCII chars, $82: Bad ASCII chars



3dh - "kr_get_string"			
-------------------

Action: Waits for user to enter a string of characters followed by return (Escape quits)
Input : xHL = location of string, E = max number of characters.
Output: If zero flag set, all OK, A = number of characters entered.
        Else: A = $80 if ESC was pressed, $81 if no characters were entered



3eh - "kr_get_version"			
--------------------

Action: Returns version info for OS and Hardware
Input : None
Output: HL = Version of PROSE OS, DE = version of AMOEBA config



3fh - "kr_dont_store_registers"	
-------------------------------

Action: Prevents the OS caching the contents of the CPU registers when an app returns control to it.
Input : None
Output: None



40h - "kr_get_font_info"		
-----------------------

Obsolete in PROSE v31+  - Do not call



41h - "kr_read_rtc"			
------------------

Action: Reads the real time clock data
Input : None
Output: xHL = location of ez80 time data: sec, min, hr, d.o,w, date, mon, year, century



42h - "kr_write_rtc"			
-------------------

Action: Writes data to the real time clock
Input : xHL = location of ez80 time data: sec, min, hr, d.o.w, date, mon, year, century
Output: None



43h - "kr_get_keymap_location"		
-----------------------------

Action: Returns location of keymap within the OS
Input : None
Output: xHL = location of keymap data within OS



44h - "kr_get_mem_base" (previously, and slightly confusingly "kr_get_os_high_mem")
-----------------------------------------------------------------------------------

Action: Returns the first available address (IE: not used by the OS) in system RAM, VRAM A and VRAM B
Input : none
Output: xHL = first free system RAM addr, xDE = same for VRAM A, xBC =same for VRAM B



45h - "kr_play_audio"
--------------------

Action: Plays sound samples
Input : xHL = Address of sound description table, C = channel enable bits.
Output: None

Notes: The sound description table format is:

 00h [3 bytes]	;location (address in VRAM B)
 03h [3 bytes]	;length in bytes
 06h [3 bytes]	;loop location (address in VRAM B)
 09h [3 bytes]	;loop length in bytes
 0ch [2 bytes]	;period constant (see hardware manual)
 0eh [1 bytes]	;volume (0-64)

The channel enable bits set in C specify which channels are to play the sound:

Bit 0 = channel 0
Bit 1 = channel 1
Bit 2 = channel 2
etc etc



46h - "kr_disable_audio"
----------------------

Action: Silences all channels by disabling the audio hardware and silencing each
        channel's volume register
Input : none
Output: none



47h - "kr_get_joysticks"
-----------------------

Action: Reads status of joystick pins
Input : none
Output: E = joystick 0, D = joystick 1

	Bit 0 = Up
	Bit 1 = Down
	Bit 2 = Left
	Bit 3 = Right
	Bit 4 = Fire 0
	Bit 5 = Fire 1

Note: Bit set = direction / button asserted.




4dh - "kr_set_timeout"
----------------------

Action: Sets the timeout period (in 32768 Hz ticks), max 65536 (two seconds)
        and starts the count down
Input : DE time-out value
Output: none





4eh - "kr_test_timeout"
----------------------

Action: Reports on status of time out flag
Input : none
Output: ZF not set if timed out (no time-out if zero flag set)




4fh - "kr_set_pointer"
----------------------

Action:  Initializes + enables / disables the mouse pointer sprite.
Input:   Set E to 1 = Enable pointer, 0 = disable pointer
         Set D to 1 = Use default PROSE pointer (no other registers required)
               If D = 0, Use custom pointer, the following parameters are required:

         HL = location of sprite data in memory (copied to sprite RAM by this routine)
         followed by:
          $xx (byte) - first palette index used by sprite
          $xx (byte) - number of colours (words) in palette data
         then.. palette data (starting from colour 1)

         C = pointer sprite height in lines (max 32)
         B = palette 0-3 to use for pointer (and all) sprites
         
Output:   Returns with Zero Flag not set if mouse driver was not activated.




50h - "kr_allocate_ram"
-----------------------

Action: Sets aside an area at the top of memory for a specific use
Input : BC = number of bytes to allocate
      : E = allocate system RAM, 1 = allocate Video RAM, 2 = allocate Sprite/Audio RAM
Output: HL = address of allocated RAM
        ZF set if allocated OK

Notes : Apps only need to allocate memory if it is to be protected from
        program loads etc after the app has exited to PROSE. EG: driver code.
        Otherwise apps can assume they have the entire (non-protected) RAM range
        to themselves, checking the free location range with "kr_get_mem_base"        
        and "kr_get_mem_top"


        
51h - "kr_deallocate_ram"
-------------------------

Action: Releases an area of RAM. IE: Moves the current allocation pointer upwards. 
Input : BC = number of bytes to deallocate
      : E = Deallocate system RAM, 1 = deallocate Video RAM, 2 = deallocate Sprite/Audio RAM
Output: None




52h - "kr_get_mem_top"
----------------------    

Action: Returns the maximum free address locations in system RAM, VRAM A and VRAM B
Input : none
Output: xHL = system RAM high, xDE = VRAM A high, xBC = VRAM B high


=========================================================================================

